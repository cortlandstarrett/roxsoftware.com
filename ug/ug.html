<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>MC-3020 Model
Compiler - User's Guide</title><link rel="stylesheet" href="techpub.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.66.1" /><meta name="description" content="This guide is the primary reference document&#10;  for the engineers and scientists translating&#10;  Nucleus BridgePoint&#10;  xtUML models with the MC-3020 model compiler. It explains how to use&#10;  the compiler's features and capabilities." /><link rel="start" href="#MC3020UserGuide" title="MC-3020 Model&#10;Compiler - User's Guide" /><link rel="next" href="#UsersGuide-chapter" title="Chapter 1. Users Guide" /></head><body><div class="book" lang="en" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="MC3020UserGuide"></a><span class="productname">MC-3020 Model
Compiler<br /></span> - User's Guide</h1></div><div><h2 class="subtitle">Escher Code Generator</h2></div><div><div class="authorgroup"><h3 class="corpauthor">Mentor Graphics Corporation</h3></div></div><div><p class="copyright">Copyright © 1998-2005 Mentor Graphics Corporation</p></div><div><p class="pubdate">August 2005</p></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>This guide is the primary reference document
  for the engineers and scientists translating
  <span class="trademark">Nucleus BridgePoint</span>®
  xtUML models with the MC-3020 model compiler. It explains how to use
  the compiler's features and capabilities.</p></div></div></div><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#UsersGuide-chapter">1. Users Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#UsersGuide-Purpose-section">Purpose and Intended Audience</a></span></dt><dd><dl><dt><span class="section"><a href="#id2467155">Purpose of the Users Guide</a></span></dt><dt><span class="section"><a href="#id2467734">Intended Audience</a></span></dt></dl></dd><dt><span class="section"><a href="#id2467912">Using the Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#id2467926">Guide Organization</a></span></dt><dt><span class="section"><a href="#id2468189">Additional Information</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Features-chapter">2. Features and Components</a></span></dt><dd><dl><dt><span class="section"><a href="#id2468452">Features</a></span></dt><dd><dl><dt><span class="section"><a href="#id2468468">Multi-Pass Corroborative Translation</a></span></dt><dt><span class="section"><a href="#id2469067">Multi-Tasking/Threading</a></span></dt><dt><span class="section"><a href="#id2469081">Prioritization</a></span></dt><dt><span class="section"><a href="#id2469114">Multi-Domain Support</a></span></dt><dt><span class="section"><a href="#id2469132">Persistence</a></span></dt><dt><span class="section"><a href="#id2469146">Metrics and Reporting</a></span></dt><dt><span class="section"><a href="#id2469174">Bridge/Operation Skeleton Generation</a></span></dt><dt><span class="section"><a href="#id2469124">``Call Outs'' for User Code</a></span></dt><dt><span class="section"><a href="#id2469260">UDT Precision and Pointer Types</a></span></dt><dt><span class="section"><a href="#id2469223">Attribute Bit Fields</a></span></dt><dt><span class="section"><a href="#id2469275">Selection Optimization</a></span></dt><dt><span class="section"><a href="#id2469288">Interrupt Handler Bridging</a></span></dt><dt><span class="section"><a href="#id2469318">User Defined Archetypes</a></span></dt><dt><span class="section"><a href="#id2469327">ANSI C Purity and Simplicity</a></span></dt><dt><span class="section"><a href="#id2469364">Preexisting Instances Defined in Data</a></span></dt><dt><span class="section"><a href="#id2469386">xtUML Model Debugger</a></span></dt></dl></dd><dt><span class="section"><a href="#id2469398">Components</a></span></dt><dd><dl><dt><span class="section"><a href="#id2469431">Classes</a></span></dt><dt><span class="section"><a href="#id2469563">Associations</a></span></dt><dt><span class="section"><a href="#id2469593">State Models</a></span></dt><dt><span class="section"><a href="#id2469681">Bridges and Operations</a></span></dt><dt><span class="section"><a href="#id2469727">Miscellaneous</a></span></dt></dl></dd><dt><span class="section"><a href="#id2469781">Restrictions and Limitations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#MCGUI-chapter">3. EDGE (Eclipse) Integration</a></span></dt><dd><dl><dt><span class="section"><a href="#id2470244">MC-3020 GUI</a></span></dt><dt><span class="section"><a href="#MCGUI-FilesFolders-section">Project Files and Folders</a></span></dt><dd><dl><dt><span class="section"><a href="#id2470881">Marking Files</a></span></dt><dt><span class="section"><a href="#id2470966">Source Files and Output</a></span></dt></dl></dd><dt><span class="section"><a href="#id2471016">Replacing Generated Source Code</a></span></dt><dt><span class="section"><a href="#id2471072">Adding User Source and Libraries</a></span></dt><dt><span class="section"><a href="#id2471080">Building (Running Code Generation)</a></span></dt><dt><span class="section"><a href="#MCGUI-Compiling-section">Compiling</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Marking-chapter">4. Marking</a></span></dt><dd><dl><dt><span class="section"><a href="#Marking-How-section">How MC-3020 Provides for
  Marking</a></span></dt><dd><dl><dt><span class="section"><a href="#id2470646">Domain Registration</a></span></dt><dt><span class="section"><a href="#id2472023">Bridge Wiring</a></span></dt><dt><span class="section"><a href="#id2472815">Specifying Data Types, Precision and Enumerators</a></span></dt><dt><span class="section"><a href="#id2473531">System Level Marks</a></span></dt><dt><span class="section"><a href="#id2471756">Domain Specializations</a></span></dt><dt><span class="section"><a href="#id2475337">Class Specializations</a></span></dt><dt><span class="section"><a href="#id2476141">Event Prioritization</a></span></dt><dt><span class="section"><a href="#Containoids-section">MC-3020 Extent Prediction and Marking</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#TranslationBuild-chapter">5. Translation and Build</a></span></dt><dd><dl><dt><span class="section"><a href="#id2480303">Files</a></span></dt><dd><dl><dt><span class="section"><a href="#id2480920">System Node</a></span></dt></dl></dd><dt><span class="section"><a href="#id2481317">rox_build:  Command Line Build Automation</a></span></dt><dd><dl><dt><span class="section"><a href="#id2481331">Utility</a></span></dt><dt><span class="section"><a href="#id2481435">Usage</a></span></dt></dl></dd><dt><span class="section"><a href="#id2481675">Sample/Example Timer (TIM)</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Enum-chapter">6. Enumerated Types</a></span></dt><dd><dl><dt><span class="section"><a href="#id2482239">Overview of Enumeration Support</a></span></dt><dt><span class="section"><a href="#id2482833">Specifying Enumerations</a></span></dt><dd><dl><dt><span class="section"><a href="#id2482881">Specifying a Discrete Value for Enumerators</a></span></dt><dt><span class="section"><a href="#id2482968">Avoiding Multiple Implementations for Enumerations</a></span></dt><dt><span class="section"><a href="#id2483034">Accessing an Enumeration from a Non-Modeled Domain</a></span></dt></dl></dd><dt><span class="section"><a href="#id2483114">Using an Enumeration</a></span></dt><dd><dl><dt><span class="section"><a href="#id2483129">Legal Uses of an Enumeration</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Callout-chapter">7. Interface Call-outs</a></span></dt><dd><dl><dt><span class="section"><a href="#id2482521">Using Callouts</a></span></dt><dd><dl><dt><span class="section"><a href="#id2483682">Callout Routines Provided</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Initialization-chapter">8. Initialization and
Preexisting Instances</a></span></dt><dd><dl><dt><span class="section"><a href="#Initialization-chapter-Overview-section">Initialization Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#id2485426">Preexisting Instances</a></span></dt><dt><span class="section"><a href="#id2485479">Terminology</a></span></dt><dt><span class="section"><a href="#id2485700">Constructs Supported</a></span></dt></dl></dd><dt><span class="section"><a href="#Initialization-chapter-DynamicInit-section">Dynamic Initialization</a></span></dt><dd><dl><dt><span class="section"><a href="#id2485785">Dynamic Init Process</a></span></dt><dt><span class="section"><a href="#id2485835">Pros and Cons of Dynamic Init</a></span></dt><dt><span class="section"><a href="#id2486199">Initialization Functions</a></span></dt><dt><span class="section"><a href="#id2486232">Rules for Creating Initialization Functions</a></span></dt><dt><span class="section"><a href="#id2486281">Example of Dynamic Initialization</a></span></dt><dt><span class="section"><a href="#id2486384">Multi-Domain Dynamic Initialization</a></span></dt><dt><span class="section"><a href="#id2486415">Multi-Domain Init Sequencing</a></span></dt><dt><span class="section"><a href="#id2486443">Initialization in Simulation</a></span></dt></dl></dd><dt><span class="section"><a href="#Initialization-chapter-ConstantInit-section">Constant Initialization</a></span></dt><dd><dl><dt><span class="section"><a href="#id2486482">Constant Initialization Process</a></span></dt><dt><span class="section"><a href="#id2486681">XML Representation of Instance Data</a></span></dt><dt><span class="section"><a href="#id2486703">Pros and Cons of Constant Init</a></span></dt><dt><span class="section"><a href="#id2486814">How To Use Constant Initialization (PEIs in Data)</a></span></dt><dt><span class="section"><a href="#id2487169">Example of Constant Initialization</a></span></dt><dt><span class="section"><a href="#id2487434">Multi-Domain Constant Initialization</a></span></dt><dt><span class="section"><a href="#id2487669">Gain from PEIs Defined in Data</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Collections-chapter">9. MC-3020 Collections</a></span></dt><dd><dl><dt><span class="section"><a href="#id2489537">MC-3020 Collections</a></span></dt><dd><dl><dt><span class="section"><a href="#id2489547">Containers</a></span></dt><dt><span class="section"><a href="#id2490184">Sets</a></span></dt><dt><span class="section"><a href="#id2490259">Set Symmetry</a></span></dt><dt><span class="section"><a href="#id2490300">Singly Linked Lists</a></span></dt><dt><span class="section"><a href="#id2490365">Doubly Linked Lists</a></span></dt><dt><span class="section"><a href="#id2490525">Performance Considerations</a></span></dt><dt><span class="section"><a href="#id2490546">Merged Containers</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Debugger-chapter">10. Model Debugger</a></span></dt><dd><dl><dt><span class="section"><a href="#id2490430">MC-3020 with Model Debugger</a></span></dt><dd><dl><dt><span class="section"><a href="#id2489942">Model Debugger Architecture</a></span></dt><dt><span class="section"><a href="#id2491339">Running MC-3020 with Model Debugger</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Persistence-chapter">11. Persistence</a></span></dt><dd><dl><dt><span class="section"><a href="#id2491344">Introduction</a></span></dt><dt><span class="section"><a href="#id2490932">High-Level Requirements</a></span></dt><dd><dl><dt><span class="section"><a href="#id2490938">Non-volatile Storage Technology</a></span></dt><dt><span class="section"><a href="#id2490956">Granularity</a></span></dt><dt><span class="section"><a href="#id2490987">Balance</a></span></dt></dl></dd><dt><span class="section"><a href="#id2491008">Operational Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#id2491016">General Scenario</a></span></dt><dt><span class="section"><a href="#id2491944">Manual and Automatic Commit</a></span></dt></dl></dd><dt><span class="section"><a href="#id2491992">Assumptions</a></span></dt><dt><span class="section"><a href="#id2492030">Limitations</a></span></dt><dt><span class="section"><a href="#id2492066">Persistence Marking Options</a></span></dt><dt><span class="section"><a href="#id2492104">Analysis</a></span></dt><dd><dl><dt><span class="section"><a href="#id2492137">Persist Domain Data Analysis</a></span></dt><dt><span class="section"><a href="#id2492174">PERSIST Domain Functions</a></span></dt><dt><span class="section"><a href="#id2492259">Non-volatile Storage Domain Data Analysis</a></span></dt><dt><span class="section"><a href="#id2492297">Non-volatile Storage Domain Functions</a></span></dt></dl></dd><dt><span class="section"><a href="#persistimplementation-section">Persistence Design</a></span></dt><dd><dl><dt><span class="section"><a href="#id2492953">Class-Based Create/Delete/Init</a></span></dt><dt><span class="section"><a href="#id2491721">Centralized Create/Delete/Init</a></span></dt><dt><span class="section"><a href="#id2493296">Implications to Persistence Support</a></span></dt><dt><span class="section"><a href="#id2493360">Implementation</a></span></dt><dt><span class="section"><a href="#id2493407">Effects</a></span></dt><dt><span class="section"><a href="#id2493443">Cost Modeling</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Tasking-chapter">12. Tasking/Threading</a></span></dt><dd><dl><dt><span class="section"><a href="#id2494488">Introduction</a></span></dt><dt><span class="section"><a href="#Tasking-Marking-section">Marking for Tasking</a></span></dt><dt><span class="section"><a href="#Tasking-Prioritization-section">Prioritization</a></span></dt><dd><dl><dt><span class="section"><a href="#Tasking-PriorityGeneration-section">Priority in the
    Generated Code</a></span></dt><dt><span class="section"><a href="#Tasking-Mapping-section">Mapping to Tasks</a></span></dt><dt><span class="section"><a href="#id2495335">How Many Tasks?</a></span></dt><dt><span class="section"><a href="#id2495369">Data Access Issues</a></span></dt></dl></dd><dt><span class="section"><a href="#Tasking-Deployment-section">Tasking/Threading in the Generated Code</a></span></dt></dl></dd><dt><span class="appendix"><a href="#Installation-appendix">A. Deployment</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2494914">Installation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2495925">Windows XP/2000/NT</a></span></dt><dt><span class="sect2"><a href="#id2496056">Solaris</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#QuickStart-appendix">B. Quick Start</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2495578">HOWTO</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2496400">Fully Automatic Demonstration</a></span></dt><dt><span class="sect2"><a href="#id2496470">Step By Step</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#AnalysisGuide-appendix">C. Analysis Guide</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2496246">Restrictions and Limitations</a></span></dt></dl></dd><dt><span class="appendix"><a href="#Background-appendix">D. Background</a></span></dt><dd><dl><dt><span class="section"><a href="#id2496363">Model Compilers (Software Architectures)</a></span></dt><dd><dl><dt><span class="section"><a href="#id2497286">Shlaer-Mellor Development</a></span></dt><dt><span class="section"><a href="#id2497659">Software Architecture Components</a></span></dt><dt><span class="section"><a href="#id2497833">Additional Components</a></span></dt><dt><span class="section"><a href="#id2497866">Model Compiler Analogy</a></span></dt></dl></dd><dt><span class="section"><a href="#id2497944">Components</a></span></dt><dd><dl><dt><span class="section"><a href="#id2497708">Mechanisms</a></span></dt><dt><span class="section"><a href="#id2497988">Archetypes</a></span></dt><dt><span class="section"><a href="#id2498018">Marks</a></span></dt><dt><span class="section"><a href="#id2498081">Build Tools</a></span></dt><dt><span class="section"><a href="#id2498106">Capabilities</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#peiinitlisting-appendix">E. PEI Test Case Setup</a></span></dt><dd><dl><dt><span class="section"><a href="#id2497230">PEI Test Case Initialization Function Listing</a></span></dt></dl></dd><dt><span class="appendix"><a href="#LegalNotice-appendix">F. Legal Notice</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>8.1. <a href="#as2class-figure">Autosampler Class Diagram</a></dt><dt>8.2. <a href="#as2init-figure">Autosampler Init Function</a></dt><dt>8.3. <a href="#peidfd-figure">
    Model Debugger Architecture</a></dt><dt>8.4. <a href="#peiclass-figure">PEI Test Case Class Diagram</a></dt><dt>8.5. <a href="#peibrowse-figure">MD System Browser for PEI
    Test Case</a></dt><dt>8.6. <a href="#mdpei-figure">MD PEI Test Case Initializing</a></dt><dt>8.7. <a href="#expclass-figure">Experiment Class Diagram</a></dt><dt>8.8. <a href="#expbrowse-figure">MD System Browser for exp and as2</a></dt><dt>8.9. <a href="#as2mdinit-figure">MD Initializing Autosampler</a></dt><dt>8.10. <a href="#expmdinit-figure">MD Initializing Experiment</a></dt><dt>9.1. <a href="#slist-figure">
    Singly Linked Lists of Instances</a></dt><dt>9.2. <a href="#dlist-figure">
    Doubly Linked Lists of Instances</a></dt><dt>9.3. <a href="#parallel-figure">
    Parallel Container/Object Arrays</a></dt><dt>9.4. <a href="#merged-figure">
    Containers Merged Into Instance Data</a></dt><dt>10.1. <a href="#debugarch1-figure">
    Model Debugger Architecture</a></dt><dt>10.2. <a href="#debugarch2-figure">
    Current Debugger/Compiler Interface</a></dt><dt>10.3. <a href="#debugarch3-figure">
    Near Term Debugger/Compiler Interface</a></dt><dt>11.1. <a href="#persistdomain-figure">Persistence Analysis Domain
  Chart</a></dt><dt>11.2. <a href="#persistim-figure">Persistence Class Diagram</a></dt><dt>11.3. <a href="#nvsim-figure">Non-Volatile Storage Class Diagram</a></dt><dt>D.1. <a href="#model-compiler-figure">
    Model Compiler Analogy with Nucleus BridgePoint Tool Set</a></dt><dt>E.1. <a href="#peiinit-figure">PEI Model Init Function</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>8.1. <a href="#id2487723">PEI Comparison</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>4.1. <a href="#id2471915">Example of xtUML Domain Registration</a></dt><dt>4.2. <a href="#id2472007">Example of Realized Domain Registration</a></dt><dt>4.3. <a href="#id2472207">Wiring Between xtUML Domains</a></dt><dt>4.4. <a href="#id2472338">Wiring Between xtUML Domains Using Bridge Object</a></dt><dt>4.5. <a href="#id2472477">Wiring a Realized Domain</a></dt><dt>4.6. <a href="#id2472625">Tagging Interrupt Bridges</a></dt><dt>4.7. <a href="#id2473074">Data Type Precision</a></dt><dt>4.8. <a href="#id2473212">Mapping Pointer Types</a></dt><dt>4.9. <a href="#id2473342">Specifying a Value for the Default Uninitialized
        Enumerator</a></dt><dt>4.10. <a href="#id2473500">Specifying Enumerator Values</a></dt><dt>4.11. <a href="#id2473681">Enabling Tasking/Threading</a></dt><dt>4.12. <a href="#id2473785">Setting Task/Thread Priority</a></dt><dt>4.13. <a href="#id2473856">Defining String Length</a></dt><dt>4.14. <a href="#id2473927">Max Relationship Extent</a></dt><dt>4.15. <a href="#id2473993">Max Selections Extent</a></dt><dt>4.16. <a href="#id2474064">Collection Node Type Selection</a></dt><dt>4.17. <a href="#id2474130">Self-Directed Queue Depth</a></dt><dt>4.18. <a href="#id2474189">Instance Directed Queue Depth</a></dt><dt>4.19. <a href="#id2474254">Pending xtUML Timers</a></dt><dt>4.20. <a href="#id2474323">Interleaved Bridges Queue Depth</a></dt><dt>4.21. <a href="#id2474388">Interleaved Bridge Argument Data</a></dt><dt>4.22. <a href="#id2471640">Enabling Model Debug Code</a></dt><dt>4.23. <a href="#id2471736">Changing Persistence Cache Queue Depth</a></dt><dt>4.24. <a href="#id2474796">Tagging Initialization Functions</a></dt><dt>4.25. <a href="#id2474892">Tagging Excluded Classes</a></dt><dt>4.26. <a href="#id2474954">Tagging Excluded Subsystems</a></dt><dt>4.27. <a href="#id2475025">Not Translating a Function</a></dt><dt>4.28. <a href="#id2475071">Enabling State Transition Tracing</a></dt><dt>4.29. <a href="#id2475115">Enabling Action Language Tracing</a></dt><dt>4.30. <a href="#id2475184">Enabling Empty Reference Usage Detection</a></dt><dt>4.31. <a href="#id2475264">Forcing Generation Non-Optimal Code</a></dt><dt>4.32. <a href="#id2475451">Mapping Classes to Tasks</a></dt><dt>4.33. <a href="#id2475543">Tagging Max Instances</a></dt><dt>4.34. <a href="#id2475606">Tagging Default Extent</a></dt><dt>4.35. <a href="#id2475697">Marking Classes as Having PEIs Defined in Data</a></dt><dt>4.36. <a href="#id2475787">Marking Classes with Static Instance Populations</a></dt><dt>4.37. <a href="#id2475873">Marking Read-Only Classes</a></dt><dt>4.38. <a href="#id2475989">Marking (Non-) Persistent Classes</a></dt><dt>4.39. <a href="#id2476124">Not Translating Operations</a></dt><dt>4.40. <a href="#id2476226">Tagging a Priority Event</a></dt><dt>5.1. <a href="#id2481635">Simple rox_build Example</a></dt><dt>5.2. <a href="#id2481649">Two Domain rox_build Example</a></dt><dt>7.1. <a href="#id2483737">Bring-up Initialization</a></dt><dt>7.2. <a href="#id2483782">Pre-xtUML Initialization</a></dt><dt>7.3. <a href="#id2483825">Post-xtUML Initialization</a></dt><dt>7.4. <a href="#id2483869">Background Processing</a></dt><dt>7.5. <a href="#id2483912">Pre-Shutdown</a></dt><dt>7.6. <a href="#id2483954">Post-Shutdown Callout</a></dt><dt>7.7. <a href="#id2484052">Event Can't Happen</a></dt><dt>7.8. <a href="#id2484149">Event with No Instance</a></dt><dt>7.9. <a href="#id2484190">Event Free List Empty Handler</a></dt><dt>7.10. <a href="#id2484243">User Empty Handle Detection</a></dt><dt>7.11. <a href="#id2484295">Object Pool Empty</a></dt><dt>7.12. <a href="#id2484344">Node List Empty</a></dt><dt>7.13. <a href="#id2484395">Overflow of Interleaved Bridge</a></dt><dt>7.14. <a href="#id2484462">Event Queue Empty Notification</a></dt></dl></div><div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="UsersGuide-chapter"></a>Chapter 1. Users Guide</h2></div></div></div><div class="highlights"><a id="UsersGuide-chapter-high"></a><p>This chapter describes
the purpose and use of this guide, lists other related documents, and
presents the conventions used within.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="UsersGuide-Purpose-section"></a>Purpose and Intended Audience</h2></div></div></div><p>This section explains the intent of this document and describes
  its usage.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2467155"></a>Purpose of the Users Guide</h3></div></div></div><p>The purpose of this guide is to enable the user of the
    MC-3020 model compiler to generate and execute an ANSI C program
    from Shlaer-Mellor xtUML models specified in the
    Nucleus BridgePoint Model Builder. Essential tasks that this guide will enable the user to
    perform include the following.
    </p><div class="itemizedlist"><ul type="disc"><li><p>Install MC-3020.</p></li><li><p>Translate xtUML models into ANSI C
      code.</p></li><li><p>Build an executable program.</p></li><li><p>Create xtUML models that fully utilize the
      capabilities of MC-3020.</p></li></ul></div><p>
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2467734"></a>Intended Audience</h3></div></div></div><p>This guide is written for software engineers who are using
    the Shlaer-Mellor development method and will implement their
    system using the MC-3020 model compiler.  It assumes that the user
    is familiar with the ANSI C programming language and general usage
    of the development platform and its software development
    utilities.</p><p>There are various roles that software engineers can play in
    the course of developing a system.  These roles reflect the
    different types of tasks that must be undertaken to successfully
    specify, design, construct, and test a system.  Roles that are
    relevant to the usage of the MC-3020 model compiler include the
    following.
    </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">Analyst</span></td><td><p>Develops the
      xtUML models on the Nucleus BridgePoint tool set that specify
      system behavior and that will be used to construct the final
      system.</p></td></tr><tr><td><span class="term">Software
      Architect</span></td><td><p>Installs and maintains the
      MC-3020 Model Compiler.  Frequently assists in its use to
      translate the xtUML models and build the
      system.</p></td></tr><tr><td><span class="term">System Architect</span></td><td><p>Makes
      system wide decisions about how the xtUML models will be
      ``marked''
      to utilize the facilities provided by MC-3020.
      This person frequently assists in the translation and building of the
      system.</p></td></tr><tr><td><span class="term">Programmer</span></td><td><p>Designs and
      develops C or other code that interfaces to the MC-3020 generated
      code.</p></td></tr><tr><td><span class="term">Tester</span></td><td><p>Tests the
      system.</p></td></tr></tbody></table></div><p>
    </p><p>An engineer in each of these roles will be looking for
    different types of information in this guide to fulfill the tasks
    of that role.</p><p>The <span class="emphasis"><em>Analyst</em></span> will want to understand how
    to use MC-3020 modeling conventions to specify such things as
    instance initialization and bridge operations. The Analyst will
    also be interested in understanding the limitations that MC-3020
    places on the xtUML models.</p><p>The <span class="emphasis"><em>Software Architect</em></span> will want to
    understand how to install and run MC-3020 as well as understand its
    structure well enough to maintain it.</p><p>The <span class="emphasis"><em>System Architect</em></span> will want to
    understand the underlying software design or architecture provided
    by MC-3020 and the marking options that are available for
    translating the xtUML models into ANSI C code.</p><p>The <span class="emphasis"><em>Programmer</em></span> will want to understand
    the published interfaces to the MC-3020 generated system and how
    to use them to successfully interact with the generated
    components.</p><p>The <span class="emphasis"><em>Tester</em></span> will want to understand how
    to execute and debug the generated system for ``black box'' testing,
    and how the system is constructed and operates for ``white box''
    testing.</p><p>The following section provides guidance on using this guide
    to meet these needs.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2467912"></a>Using the Guide</h2></div></div></div><div class="highlights"><p>This section describes the general structure of
  this guide and provides suggestions for its usage in different
  situations.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2467926"></a>Guide Organization</h3></div></div></div><p>The guide is assembled with the more frequently accessed
    chapters toward the front.  These chapters are in roughly
    chronological order according to how they will be used.  General
    Shlaer-Mellor development background is provided toward the end.</p><p>Here is a short description of each chapter and
    appendix.</p><p>
    </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">
      <a href="#UsersGuide-chapter" title="Chapter 1. Users Guide">Chapter 1, <i>Users Guide</i></a>
      </span></td><td><p>
      <a href="#UsersGuide-chapter"><p>This chapter describes
the purpose and use of this guide, lists other related documents, and
presents the conventions used within.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#Features-chapter" title="Chapter 2. Features and Components">Chapter 2, <i>Features and Components</i></a>
      </span></td><td><p>
      <a href="#Features-chapter"><p>This chapter
provides a concise overview of many of the capabilities built
into MC-3020.  The basic gist of translation strategy for model
components is given in an outline format.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#MCGUI-chapter" title="Chapter 3. EDGE (Eclipse) Integration">Chapter 3, <i>EDGE (Eclipse) Integration</i></a>
      </span></td><td><p>
      <a href="#MCGUI-chapter"><p>The MC-3020 build process
has been integrated with Nucleus BridgePoint Model Debugger version 7 and Nucleus EDGE, the Embedded
Developers Graphical Environment.  EDGE is based upon the Eclipse
framework.  The use of MC-3020 in this environment is described in
this section.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#Marking-chapter" title="Chapter 4. Marking">Chapter 4, <i>Marking</i></a>
      </span></td><td><p>
      <a href="#Marking-chapter"><p>MC-3020 provides
a rich set of ``knobs and dials'' that can be spun to optimize
and customize the code generation process.  This chapter
gives instructions on the use of these marking parameters.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#TranslationBuild-chapter" title="Chapter 5. Translation and Build">Chapter 5, <i>Translation and Build</i></a>
      </span></td><td><p>
      <a href="#TranslationBuild-chapter"><p>This chapter
explains the mechanics of turning xtUML models into C code using
MC-3020.  The build environment is composed of a set of shell
scripts and makefiles.  Step by step usage is provided.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#Enum-chapter" title="Chapter 6. Enumerated Types">Chapter 6, <i>Enumerated Types</i></a>
      </span></td><td><p>
      <a href="#Enum-chapter"><p>Nucleus BridgePoint Model Builder allows users
to define types derived from its set of core data types.
Support for the Nucleus BridgePoint Model Builder interface for defining enumerated types
is fully supported.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#Callout-chapter" title="Chapter 7. Interface Call-outs">Chapter 7, <i>Interface Call-outs</i></a>
      </span></td><td><p>
      <a href="#Callout-chapter"><p>Interface call-outs
allow the user to capture execution control of the generated system
running on a target.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#Initialization-chapter" title="Chapter 8. Initialization and&#10;Preexisting Instances">Chapter 8, <i>Initialization and
Preexisting Instances</i></a>
      </span></td><td><p>
      <a href="#Initialization-chapter"><p>This chapter
explains how to initialize and start the system.  Initialization
must deal with bringing up the architecture system code as well
as initialization for preexisting instances.
</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#Collections-chapter" title="Chapter 9. MC-3020 Collections">Chapter 9, <i>MC-3020 Collections</i></a>
      </span></td><td><p>
      <a href="#Collections-chapter"><p>Lists are used by MC-3020
to keep track of collections of instances in the system.  Collections
of instances appear in several contexts including pools of instances
of classes, sets of instances participating in an association and
sets of instances resulting from SELECT MANY statements.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#Debugger-chapter" title="Chapter 10. Model Debugger">Chapter 10, <i>Model Debugger</i></a>
      </span></td><td><p>
      <a href="#Debugger-chapter"><p>As of version 3.1
MC-3020 supports debugging with the Nucleus BridgePoint Model Debugger.  This adds powerful
capabilities to the software developer.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#Persistence-chapter" title="Chapter 11. Persistence">Chapter 11, <i>Persistence</i></a>
      </span></td><td><p>
      <a href="#Persistence-chapter"><p>This chapter describes
persistence services for MC-3020.  The persistence support in MC-3020
allows instances of classes marked as persistent to survive across
power cycles.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#Tasking-chapter" title="Chapter 12. Tasking/Threading">Chapter 12, <i>Tasking/Threading</i></a>
      </span></td><td><p>
      <a href="#Tasking-chapter"><p>MC-3020 supports running
the xtUML application within multiple tasks or threads.  The tasking
uses the underlying OS/RTOS when one exists.  MC-3020 can still run
without an OS/RTOS, but if preemptive multi-tasking is desired in
the application, it is available.  The tasking/threading
capabilities for MC-3020 are outlined here.</p></a>
      </p></td></tr></tbody></table></div><p>
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2468189"></a>Additional Information</h3></div></div></div><p>Appendices have been provided.
    </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">
      <a href="#Installation-appendix" title="Appendix A. Deployment">Appendix A, <i>Deployment</i></a>
      </span></td><td><p>
      <a href="#Installation-appendix"><p>Find here
step by step instructions for installing MC-3020 onto the
development platform.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#QuickStart-appendix" title="Appendix B. Quick Start">Appendix B, <i>Quick Start</i></a>
      </span></td><td><p>
      <a href="#QuickStart-appendix"><p>Get MC-3020 up and
running right ``out of the box''.  Instructions are provided
here to build a sample system.  It is a simple matter to substitute
a different model for the sample provided here.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#AnalysisGuide-appendix" title="Appendix C. Analysis Guide">Appendix C, <i>Analysis Guide</i></a>
      </span></td><td><p>
      <a href="#AnalysisGuide-appendix"><p>MC-3020
levies certain restrictions upon the analyst.  These restrictions
and advice for capitalizing upon MC-3020 features are
provided.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#Background-appendix" title="Appendix D. Background">Appendix D, <i>Background</i></a>
      </span></td><td><p>
      <a href="#Background-appendix"><p>This appendix begins
by providing a general overview of model compilers (sometimes
referred to as the <span class="emphasis"><em>software architecture</em></span>)
followed by a brief description of the major components of MC-3020.
Next, a more detailed look is taken at the two types of tasks found
in the MC-3020 architecture and how they interact.  Finally, the
general operational nature of each task type is described. The intent
is to provide the reader with a complete, high level view of the
MC-3020 architecture, sufficient to provide a context for the rest
of this manual.</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#peiinitlisting-appendix" title="Appendix E. PEI Test Case Setup">Appendix E, <i>PEI Test Case Setup</i></a>
      </span></td><td><p>
      <a href="#peiinitlisting-appendix"><p>The PEI test
case setup domain function is listed here in it entirety.
</p></a>
      </p></td></tr><tr><td><span class="term">
      <a href="#LegalNotice-appendix" title="Appendix F. Legal Notice">Appendix F, <i>Legal Notice</i></a>
      </span></td><td><p>
      <a href="#LegalNotice-appendix"><p>MC-3020
is commercial software and its use is restricted and limited
by license.</p></a>
      </p></td></tr></tbody></table></div><p>
    </p></div></div></div><div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="Features-chapter"></a>Chapter 2. Features and Components</h2></div></div></div><div class="highlights"><a id="Features-chapter-high"></a><p>This chapter
provides a concise overview of many of the capabilities built
into MC-3020.  The basic gist of translation strategy for model
components is given in an outline format.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2468452"></a>Features</h2></div></div></div><p>MC-3020 delivers translation technology and a set of features
  and components found in no other model compiler existing to date.  
  The mix of optimizations, conveniences and simplicity provide a
  solid foundation upon which ``down on the iron'' embedded designs
  can be based.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2468468"></a>Multi-Pass Corroborative Translation</h3></div></div></div><p>The translation engine embodied in the MC-3020 Model Compiler performs
    two passes across the xtUML model under translation.  The first pass
    analyzes the model structure and action language semantics of each
    domain.  The results of this analysis drive the generation in the
    second pass.  The second pass generates code and data that is
    minimized and optimized for speed.  Unaccessed data and unneeded
    code are eliminated.</p><p>This multi-pass intelligence spans domains and allows for
    optimizations at the system level based on information collected
    and collated from all domains in the system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469067"></a>Multi-Tasking/Threading</h3></div></div></div><p>Preemptive multi-tasking is supported on the
    <span class="trademark">Nucleus PLUS</span>® real-time
    operation system (RTOS) and on systems supporting POSIX threading.
    Single-task operation (with or without and RTOS) is also supported.
    Tasking supplies a rich means of providing preemptive prioritization
    among the xtUML classes running in the system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469081"></a>Prioritization</h3></div></div></div><p>Preemptive task/thread prioritization is provided in
    the generated C code.  Groups of xtUML classes are mapped to
    tasks running at differing priorities.</p><p>MC-3020 also provides for prioritization through the
    marking of events.  Higher priority xtUML threads of control
    can run without being preempted by lower priority activities.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469114"></a>Multi-Domain Support</h3></div></div></div><p>MC-3020 cleanly translates large systems consisting of
    multiple xtUML and realized domains.  Support is provided to
    integrate and interface to hand-craft, legacy and/or off-the-shelf
    code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469132"></a>Persistence</h3></div></div></div><p>MC-3020 supports the marking of persistent classes.
    The instance data for classes marked as persistent is restored
    at power-up from a non-volatile storage (NVS) device.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469146"></a>Metrics and Reporting</h3></div></div></div><p>A set of metrics is generated and reported each time the
    model compiler is run.  Statistics on classes, associations,
    events and first pass analysis results are stored in a report
    directory.</p><p>Metrics provided can be fed back to the analyst to provide a
    focus on recognized dangerous practices and fully illegal
    operations and accesses.  Some of the metrics relate to sizing
    and complexity.  These metrics could easily be tracked
    over the life of a project to provide quality and effort related
    measurements.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469174"></a>Bridge/Operation Skeleton Generation</h3></div></div></div><p>Based upon information modeled in Nucleus BridgePoint Model Builder MC-3020 automatically
    generates source code frameworks for operations and outbound bridge
    implementation.  These skeleton files will actually compile
    as generated.  The user is saved from delving into generated
    code to divine interfaces required for these boundary functions.
    Kind and helpful comments are provided to guide insertion of
    bridge and operation implementation code.</p><p>Support is provided for translation of AL in operation
    and bridge descriptions.  The same action language used for Nucleus BridgePoint Model Verifier
    is translated into the of bodies of the operation C source
    files and the bridge skeleton files.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469124"></a>``Call Outs'' for User Code</h3></div></div></div><p>Several hooks have been supplied to allow easy interfacing
    of user supplied code to the system level generated code.
    A source module is automatically generated that supplies
    empty functions which are invoked at various points during
    initialization, dispatch processing and shut down.  These
    empty functions can be populated with user code for ``can't
    happen'' events,
    hardware bring-up, ``background'' processing, legacy
    clean-up and more.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469260"></a>UDT Precision and Pointer Types</h3></div></div></div><p>To allow optimization for space and control over
    precision, the storage classes of integer and real based
    user-defined
    data types (UDTs) can be supplied by the user.
    MC-3020 also allows user-defined data types to be
    implemented as pointers.  The pointer types are very
    convenient for passing across bridges (in both directions).
    Precision and pointer information is provided to the
    model compiler through marking.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469223"></a>Attribute Bit Fields</h3></div></div></div><p>Further optimization of space is provided through
    ANSI C bit field support.  Multiple attributes can be packed
    into a single word of storage.  This feature may also be
    used (with caution) in conjunction with memory mapped classes
    to model hardware with xtUML constructs.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469275"></a>Selection Optimization</h3></div></div></div><p>MC-3020 attempts to optimize <span><b class="command">select
    any [inst_ref] from instances of [key_letters] where
    [where clause]</b></span> when the where clause
    is checking for equality of the identifier.  MC-3020
    optimizes for code space.  In addition,
    hooks into the scanning routines are provided to enable
    customizations to the selection search algorithms.
    Applications dealing with large collections of class
    instance data (hundreds or thousands) may use these hooks
    to further speed the selection process.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469288"></a>Interrupt Handler Bridging</h3></div></div></div><p>MC-3020 provides a safe way to bridge into the application
    from interrupt handlers (or other external tasks).  Consistency is
    maintained in software architecture data structures and
    application data access sets.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469318"></a>User Defined Archetypes</h3></div></div></div><p>A means is provided for the user to supply application
    specific fule file functions.  This capability serves to
    extend the marking capabilities of MC-3020.  It is possible
    to steer code generation in such a way as to provide customizations
    characteristic of particular target platforms, compilers and
    tool sets.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469327"></a>ANSI C Purity and Simplicity</h3></div></div></div><p>MC-3020 is purely ANSI C and generates code that can be compiled
    by any compiler compliant with the ANSI standard.  The core
    model compiler uses no libraries or system functions.
    <tt class="filename">stdio.h</tt> is included simply for convenience
    during debug (for <span><b class="command">printf</b></span>, etc).  All generated
    code is simple, native C.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469364"></a>Preexisting Instances Defined in Data</h3></div></div></div><p>As of version 3.1, MC-3020 supports initialization of
    preexisting instances in data.  This provides a substantial
    optimization in both bring-up execution speed and overall code
    footprint.  Instead of creating, relating and initializing all
    of the classes at start-up, pre-existing class instances can be
    pre-populated with static initializers.  Support is maintained for
    dynamic initialization using an initialization function (or an
    initialization object).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469386"></a>xtUML Model Debugger</h3></div></div></div><p>As of version 3.1, MC-3020 supports xtUML-level model
    debugging with Nucleus BridgePoint Model Debugger.  This support allows execution tracing
    at state action as well as the AL statement level.  The state
    of the system can be openly queried and viewed at any point
    of execution.  Support is limited to execution on the host
    computer or socket-capable targets with sufficient RAM
    capacity.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2469398"></a>Components</h2></div></div></div><p>MC-3020 is a modular software architecture characterized by a
  distinct effort to maximize component independence.  The coupling
  between the model compiler components has been minimized while
  maximizing component cohesion.  A model of the architecture drives the
  implementation of the generation components.</p><p>To a great extent components can be modified independently.
  Additional components can be added.  This makes MC-3020 ideal for
  extension and modification.  In a limited fashion, individual
  architecture components can be ``unplugged'' and new or modified
  components ``plugged in'' to replace them.  For example, the strategy
  for collecting instances can be changed by modifying or replacing
  only the localized component.  Names and coding style rules are
  concentrated into a single component allowing architects to dial
  in a preferred naming convention and generation style.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469431"></a>Classes</h3></div></div></div><p> Each class is translated into an ANSI C structure.  Instances
    are maintained in collections of instances of classes (class
    extents).  Space for class instances is
    pre-allocated at bring-up time.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2469462"></a>Creation</h4></div></div></div><p>Creation occurs in constant time.  Creation can occur
      synchronously with the create action language statement or
      asynchronously with a creation event.  In synchronous creation,
      no action is executed.  In asynchronous creation, a creation
      state is executed and at minimum initializes the instance
      identifier.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2469483"></a>Deletion</h4></div></div></div><p>Instance deletion moves an class instance from the
      active extent and deactivates it onto a list of inactive
      (``inanimate'') class instances.  If no action language
      ever performs deletion of a particular class, no deletion
      accessor method is generated.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2469503"></a>Selection</h4></div></div></div><p>Instance selection is optimized for speed when selecting
      based on the instance identifier.  For unoptimized selections O(N)
      (linear) time is required.  (MC-3020 provides
      O(N) for all ``blind selections'', <span><b class="command">select any from
      instances of</b></span> action language commands.)
      Hooks are provided for architect replacement of certain
      signature selection search functions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2469530"></a>Attributes</h4></div></div></div><p> Attributes are elements of the translated structure.  Most
      attributes are translated with no function interface layer.  No
      call/return overhead is incurred for most attribute read and
      write operations.  Code is generated to directly access attribute
      data.  Speed is optimized.</p><p>In typical models, some attributes are never accessed.
      MC-3020 detects this situation and omits the implementation of
      attribute data elements that are never accessed.  Unused data is
      optimized away.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469563"></a>Associations</h3></div></div></div><p> Associations are optimized by storing a copy of the instance
    handle as extended attribute data.  This optimization is
    implemented between sub/super-types as well.</p><p>As with data attribute elements, MC-3020 optimizes away
    unused referential attributes.  Relate, unrelate (link and unlink)
    and association traversal operations are optimized for low
    overhead.  These operations are performed directly on instance data
    when appropriate avoiding the generation and associated run time
    overhead of function calls.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469593"></a>State Models</h3></div></div></div><p> The translated state models are optimized for speed.  State
    transitions and action dispatches execute in constant time.
    The state event matrix is implemented as a two dimensional
    array.  Rows represent states; columns are indexed by event
    to obtain the transition.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2469612"></a>Actions</h4></div></div></div><p> Actions are translated into functions associated by
      name and packaging with the class containing the state model
      containing the state action.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2469626"></a>Events</h4></div></div></div><p>Adherence to Shlaer-Mellor event rules is assured in the generated
      code.  Centralized event queues order events for the entire
      system.</p><p>Prioritized events can be marked by the user. 256
      priority levels are provided.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2469646"></a>Creation Events</h4></div></div></div><p> Creation events are recognized and treated differently
      from non-creation events.  The model compiler will create an
      instance of the class before the event is delivered.  The event
      will cause a transition into the creation state and execution of
      the associated action.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2469667"></a>Final States</h4></div></div></div><p> Final state actions delete self after executing the
      specified processing.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469681"></a>Bridges and Operations</h3></div></div></div><p> Domain functions (bridges) and operations are listed together, because
    MC-3020 treats them with a great deal of symmetry.  Domain functions and
    operations translate into C function invocations.  Any number of
    arguments can be passed.</p><p>Domain functions (synchronous services) are supported between
    domains.  Events across bridges are not allowed.</p><p>MC-3020 generates bridge and operation frameworks.  These
    frameworks provide the entire invocation interface.  A comment is
    provided to guide the user in where to insert implementation code.
    These skeletons will compile with or without inserted user code.
    However, the bridge must be declared to the generation system and
    the bridge must be wired.  See <a href="#Marking-chapter" title="Chapter 4. Marking">Chapter 4, <i>Marking</i></a>
    for details on how to accomplish this.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2469727"></a>Miscellaneous</h3></div></div></div><p>These are the unclassified features.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2469736"></a>Initialization</h4></div></div></div><p> Marking allows Nucleus BridgePoint Model Verifier flavored initialization objects
      to be used for system initialization.  In addition, several
      initialization objects can be defined in the model and
      only one marked to generate code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2469752"></a>Style Dials</h4></div></div></div><p> Various stylistic and implementation conventions are
      centralized and documented to be easily controlled by the software
      architect.  Generated file names, directory structure, coding
      conventions and even coding style can be dialed in by the user.
      (Look for fule files with the word ``name'' in the file name.)
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2469773"></a>Metrics</h4></div></div></div><p>MC-3020 is tooled to support a measured development
      process.  As with style, metrics can be customized easily.
      MC-3020 gathers and reports many metrics including statistics
      quantifying classes, states models, state actions, event flavors,
      association and marking summary information.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2469781"></a>Restrictions and Limitations</h2></div></div></div><p>See release notes for most recent restrictions and limitations.
  </p><div class="itemizedlist"><ul type="disc"><li><p>No dynamic memory allocation.  System storage space
    for all instances is pre-allocated at start-up.  This implies
    marking the OIM to define the maximum number of instances needed
    for each class.  Note that MC-3020 intelligently determines
    rational defaults for instance and event populations.  Sophisticated
    analysis is performed to size instance, event and queue
    populations across multiple domains.  Marking
    is used to dial these in tightly.</p></li><li><p>Some platforms have no real time clock.  Therefore
    date and time may not be available in standard Gregorian or Caesarian
    form.</p></li><li><p>State machines are optimized for speed rather than
    space.</p></li><li><p>Events across bridges are not
    allowed.</p></li><li><p>Navigations of composed associations must explicitly
    use the ``real'' (non-composed) association
    formalizations.</p></li><li><p>Association conditionality is not enforced by
    the model compiler.</p></li><li><p>Actions may not leave identifying attributes
    inconsistent beyond the end of any action.</p></li><li><p>MC-3020 attempts to optimize <span><b class="command">select
    any [inst_ref] from instances of [key_letters] where
    [where clause]</b></span> for code size when the where clause
    is checking for equality of the identifier.  Future versions
    of MC-3020 may provide advanced (hashed) searching techniques
    to optimize the blind selections for speed.  In MC-3020,
    certain limitations apply to the selection
    optimization when unnecessary parentheses are used in the
    where clause expression.  To guarantee the best optimization,
    avoid unnecessary parentheses in where clauses.</p></li><li><p>Blind selections following a create and in the same
    scope as the create may not see the newly created instance in the
    extent.</p></li><li><p><span><b class="command">create object instance of</b></span>
    <span class="emphasis"><em>keyletters</em></span> (create with no return
    value) is allowed only when the identifier of
    class <span class="emphasis"><em>keyletters</em></span> is of type
    unique_ID.</p></li><li><p>The implementation of string expressions
    is somewhat inelegant.  Strings in expressions are limited to simple
    binary operations.  For example
    </p><pre class="programlisting">company = "Mentor" + "Graphics" + "Corp.";</pre><p>
    results in a compilation error.  The alternative,
    </p><pre class="programlisting">company = "Mentor" + "Graphics";</pre><p>
    </p><pre class="programlisting">company = company + "Corp.";</pre><p>
    must be used to
    work around this shortcoming.</p></li><li><p>There is no support for ``N to N + 1'' release
    compatibility.  Changes to a model result in changes in the code,
    including event numbers, state numbers, etc.  The registration
    theme is introduced to pave the way for future N+1 release
    capability.</p></li></ul></div><p>
  </p></div></div><div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="MCGUI-chapter"></a>Chapter 3. EDGE (Eclipse) Integration</h2></div></div></div><div class="highlights"><a id="MCGUI-chapter-high"></a><p>The MC-3020 build process
has been integrated with Nucleus BridgePoint Model Debugger version 7 and Nucleus EDGE, the Embedded
Developers Graphical Environment.  EDGE is based upon the Eclipse
framework.  The use of MC-3020 in this environment is described in
this section.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2470244"></a>MC-3020 GUI</h2></div></div></div><p>MC-3020 can now be run from inside of Nucleus BridgePoint Model Builder/EDGE.  Nucleus BridgePoint Model Builder
  version 7 now runs within an Eclipse environment.  This environment
  provides excellent flexibility to integrate tools together.  Eclipse
  is open and easy to modify.  EDGE is the name of the Eclipse
  environment as customized for xtUML and embedded development.</p><p>Read the user guides for Nucleus BridgePoint Model Builder version 7 and view the
  online documentation from within EDGE.</p><p>All of the marking capabilities of MC-3020 are available from
  within the EDGE user interface.</p><p>Following the instructions when creating a New Project will
  result in all of the model compiler related marking files will be
  present in the project.  These files and folders are described in
  more detail below.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="MCGUI-FilesFolders-section"></a>Project Files and Folders</h2></div></div></div><p>The files for a project reside within the project folder.  All
  of the files having to do with the project exist within this folder
  (or are linked into this folder using Eclipse links).  Some of the 
  files and folders in the project are part of the model compilation
  and code generation process.  The <tt class="filename">gen</tt> and
  <tt class="filename">src</tt> folders in the project are used by the model
  compiler.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2470881"></a>Marking Files</h3></div></div></div><p>All of the marking files for a project will be found in the
    <tt class="filename">gen</tt> folder.  These files can be edited by
    double-clicking on the file or by right clicking and opening the
    file for editing.  Note that the marking files end with the file
    extension <tt class="filename">.mark</tt>.  System level marking files
    include <tt class="filename">bridge.mark</tt>,
    <tt class="filename">datatype.mark</tt>,
    <tt class="filename">registry.mark</tt> and
    <tt class="filename">system.mark</tt>.</p><p>The domain level marking files are prepended with the name of
    the xtUML model (domain) with which they are associated.  There
    will be a class marking file
    <span class="emphasis"><em>[model]</em></span>_<tt class="filename">class.mark</tt>, a
    domain marking file
    <span class="emphasis"><em>[model]</em></span>_<tt class="filename">domain.mark</tt> and
    an event marking file
    <span class="emphasis"><em>[model]</em></span>_<tt class="filename">event.mark</tt> for
    each model (domain) in the project.</p><p>To supply marking to the code generation process, edit the
    marking files.  <a href="#Marking-chapter" title="Chapter 4. Marking">Chapter 4, <i>Marking</i></a> explains the
    markings available to control the code generation of
    MC-3020</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2470966"></a>Source Files and Output</h3></div></div></div><p>The code generation process creates a folder called
    <tt class="filename">code_generation</tt> in the
    <tt class="filename">gen</tt> folder.  The is the generation workspace
    and is largely a temporary ("scratch") work area for the model
    compiler.  It will be deleted before new code generation begins.
    The <tt class="filename">code_generation</tt> folder contains the files
    and folders that users of MC-3020 versions 3.3 and before are
    accustomed to seeing.</p><p>After code generation runs to completion, the generated
    source code will be copied into the <tt class="filename">src</tt> folder
    of the project.  If running with Nucleus BridgePoint Model Debugger marking enabled, an XML
    file for each debugged model will also be copied into this
    folder.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2471016"></a>Replacing Generated Source Code</h2></div></div></div><p>In some circumstances it is desirable to replace code generated
  by MC-3020 with code supplied by the user.  This is often the case
  with the timer subsystem (TIM) in <tt class="filename">TIM_bridge.c</tt>
  and almost always the case with the system user callouts
  (<tt class="filename">sys_user_co.c</tt> and
  <tt class="filename">sys_user_co.h</tt>).  In these cases, replacement
  source files must be supplied to the code generation process.</p><p>To supply user source code that will replace files of the same
  name generated by MC-3020, place the source files
  (<tt class="filename">.c</tt> and <tt class="filename">.h</tt>) in the 
  <tt class="filename">gen</tt> folder within the project folder.  When the
  code generation process runs, the supplied files will be copied in to
  overwrite/replace those generated by the model compiler.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2471072"></a>Adding User Source and Libraries</h2></div></div></div><p>MC-3020 supports the integration of user supplied source
  code (<tt class="filename">.c</tt> and <tt class="filename">.h</tt> files)
  and libraries (<tt class="filename">.a</tt> and
  <tt class="filename">.dll</tt>).  To add additional source code and
  libraries to the generated and compiled system, simply deposit
  files into the <tt class="filename">src</tt> folder within the project
  folder.</p><p>EDGE will detect these source files and libraries anywhere
  within the project <span class="emphasis"><em>except</em></span> within the
  <tt class="filename">gen</tt> folder and within the
  <tt class="filename">models</tt> folder.  It is recommended that the
  user create sub-folders within the <tt class="filename">src</tt> folder
  to organize the added source code and libraries.</p><p>Note that the naming conventions used by the source code and
  libraries being added should differ substantially from the naming
  conventions used in the MC-3020 generated code.  Careful naming
  will avoid name collisions and conflicts between generated code and
  added code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2471080"></a>Building (Running Code Generation)</h2></div></div></div><p>To start the code generation process, right click on the
  project and select "Build Project".  This will cause code
  generation (MC-3020 execution) to begin.  All models in the
  project will be translated.  The generated source code will be
  copied into the <tt class="filename">src</tt> folder in the
  project.</p><p>It is also possible to begin code generation by pressing the
  "Build All" button on the Eclipse toolbar or by selecting one of
  "Build All", "Build Project" or "Clean..." from the Eclipse
  "Project" menu.  Note that these alternative methods of starting
  the build will also start a build for all other open projects
  within the Eclipse workspace.  Be sure this is what is intended
  when using these methods to begin the build process.</p><p>Output code generation logging will appear in the Eclipse
  console.</p><p>To stop code generation, press the square, red stop button in
  the console view during code generation.</p><p>Code compilation will occur after code is generated.  See
  <a href="#MCGUI-Compiling-section" title="Compiling">the section called “Compiling”</a> below.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="MCGUI-Compiling-section"></a>Compiling</h2></div></div></div><p>Compiling code from within the EDGE is automatic.  As
  MC-3020 generates source code files and deposits them into the
  <tt class="filename">src</tt> folder, EDGE "notices" them, compiles
  them and links them all together.  The C compiler (toolset) was
  chosen when the project was created.</p></div></div><div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="Marking-chapter"></a>Chapter 4. Marking</h2></div></div></div><div class="highlights"><a id="Marking-chapter-high"></a><p>MC-3020 provides
a rich set of ``knobs and dials'' that can be spun to optimize
and customize the code generation process.  This chapter
gives instructions on the use of these marking parameters.</p></div><p>Formerly termed "coloring", <span class="emphasis"><em>marking</em></span>
is the primary means of steering and controlling the
code generation process.  When there is more than one software
architecture element into which an xtUML element can be translated,
<span class="emphasis"><em>marks</em></span> are used to indicate which translation
to make.  The name ``mark'' comes from the visualization of using
a highlighter pen to mark each element that has a particular
property.  Marks are used to direct the translation to select one
of two or more branches in the translation rules.  It is through
marking that design decisions are injected during the translation
process.</p><p>An example of the type of design information that is
specified through marking is the mapping of analysis data types
into implementation (e.g., C) data types.  Clearly, this is
information that does not belong in either the xtUML models or the
model compiler itself.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Marking-How-section"></a>How MC-3020 Provides for
  Marking</h2></div></div></div><div class="highlights"><p>Marking capability can be provided in many
  different ways.  In MC-3020 marking input is communicated to the
  model compiler through marking files read during
  translation.  Other marking input is provided through key words
  placed in artifact description with Nucleus BridgePoint Model Builder.  This is similar to
  the way enumerations are identified to Nucleus BridgePoint Model Builder.
  Marking input steers the code generation by
  selecting between alternatives during code
  generation.</p></div><p>Some marking is mandatory; some marking is optional.  In the
  case of optional marking, the model compiler will assume reasonable
  defaults.  In the case of mandatory marking, the model compiler is
  not capable of divining the intent of the user and will abort the
  translation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2470646"></a>Domain Registration</h3></div></div></div><p>Domain Registration is a reflection of the Shlaer-Mellor domain
    chart.  All domains are declared in the registration marking
    file.</p><p>The <tt class="filename">registry.clr</tt> marking file is used
    to register all the domains, both xtUML and realized, which will be
    used to construct system load images.  Domain registration is a
    mandatory marking file.  Domains are registered by providing a
    registered name in correlation with a repository name.
    Registration of domains provides indirection between the name
    space of Nucleus BridgePoint Model Builder and the generation and build environments.
    Registration provides a clean break between the naming choices of
    the analysts and model maintainers and the back end code
    generation.  This conveniently allows the same model to be named
    differently in different repositories, or for versioning of
    models to be independent of versioning of the generation.</p><p>To register the domains in the system, edit
    <tt class="filename">registry.clr</tt>.
    </p><div class="itemizedlist"><ul type="disc"><li><p>Marking is specified via rule file function
      invocation(s) in this file.  A function invocation statement
      must be specified on a single line.  All indicated function
      input parameters must be supplied.</p></li><li><p>All quoted string parameters are case
      sensitive.</p></li><li><p>Comments in this file start with
      ".//".</p></li><li><p>Do not leave any blank lines in this
      file.</p></li><li><p>Registered domain names and numbers must be
      unique.</p></li><li><p>Domain ID number zero (0) is reserved for the
      model compiler.</p></li></ul></div><p>
    </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2471835"></a>Registering xtUML Domains</h4></div></div></div><p>To indicate to MC-3020 that an xtUML domain is part
      of a system build, provide the following rule file function
      invocation in
      the <tt class="filename">registry.clr</tt> marking file.
      </p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef"><b class="fsfunc">RegisterOoaDomain</b>(</code></td><td>string  </td><td><var class="pdparam">"repository_name"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"registered_name"</var>, </td></tr><tr><td> </td><td>integer  </td><td><var class="pdparam">registered_id</var><code>)</code>;</td></tr></table></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">repository_name</span></td><td><p>xtUML domain
        repository name</p></td></tr><tr><td><span class="term">registered_name</span></td><td><p>registered
        domain name</p></td></tr><tr><td><span class="term">registered_id</span></td><td><p>registered
        domain number</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2471915"></a><p class="title"><b>Example 4.1. Example of xtUML Domain Registration</b></p><pre class="programlisting">
.invoke RegisterOoaDomain( "autosampler", "AS", 69 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2471930"></a>Registering Realized Domains</h4></div></div></div><p>To indicate to the model compiler that a realized
      (non-xtUML) domain is part of a system build, make the following
      rule file function invocation, one for each realized domain, from 
      the <tt class="filename">registry.clr</tt> marking file.
      </p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef"><b class="fsfunc">RegisterRealizedDomain</b>(</code></td><td>string  </td><td><var class="pdparam">"description"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"registered_name"</var>, </td></tr><tr><td> </td><td>integer  </td><td><var class="pdparam">registered_id</var><code>)</code>;</td></tr></table></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">description</span></td><td><p>optional
        textual description of the realized domain
        (Use "" as a default description.)</p></td></tr><tr><td><span class="term">registered_name</span></td><td><p>registered
        domain name</p></td></tr><tr><td><span class="term">registered_id</span></td><td><p>registered
        domain number</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2472007"></a><p class="title"><b>Example 4.2. Example of Realized Domain Registration</b></p><pre class="programlisting">
.invoke RegisterRealizedDomain( "", "CARPIO", 101 )
        </pre></div><p>
      </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2472023"></a>Bridge Wiring</h3></div></div></div><p>The <tt class="filename">registry.clr</tt> described
    above declares the
    names and types of the domains on the domain chart to be
    included in the system build.
    To round out the manifestation of the domain chart,
    bridges are <span class="emphasis"><em>wired</em></span> together in
    the <tt class="filename">bridge.clr</tt> file.  The word
    ``wiring'' is used as an analogy to an electrical circuit.
    After the components of a circuit are placed, the interconnecting
    wires must be defined.  In like manner, domains on a domain
    chart are interconnected with bridges.  These bridges must
    be declared in the bridge marking file.</p><p>The <tt class="filename">bridge.clr</tt> marking file is used
    to wire together all the domains, both xtUML and realized.
    This marking file is used to specify inter-domain bridge signatures
    to the model compiler's translation engine.  All references to a
    domain name in this file correspond to the registered domain
    name, and not the Nucleus BridgePoint domain repository name.</p><p>Beginning with version 2.0 of MC-3020 there are two ways
    to wire bridges between xtUML domains.  The new method
    wires bridges using Synchronous Services (Domain Functions); the
    old way uses Bridge Objects (FBOs).  Synchronous Service bridges
    are preferred, because they provide a cleaner interface.</p><p>To wire the domains in the system together, edit
    <tt class="filename">bridge.clr</tt>.
    </p><div class="itemizedlist"><ul type="disc"><li><p>Marking is specified via rule file function
      invocation(s) in this file.  A function invocation statement
      must be specified on a single line.  All indicated function
      input parameters must be supplied.</p></li><li><p>All quoted string parameters are case
      sensitive.</p></li><li><p>Comments in this file start with
      ".//".</p></li><li><p>Do not leave any blank lines in this
      file.</p></li></ul></div><p>
    </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2472124"></a>Wiring an xtUML Bridge Using Synchronous Services</h4></div></div></div><p>Synchronous services, also known as domain functions,
      provide a convenient home for a reusable package of processing
      requiring no state.  Synchronous services can be invoked from
      within the domain or from without.  Bridging is only concerned
      with connecting the interface to external entities.</p><p>
      </p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef"><b class="fsfunc">WireSynchServiceOoaBridge</b>(</code></td><td>string  </td><td><var class="pdparam">"initiating_dom"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"ee_key_letters"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"recip_domain"</var><code>)</code>;</td></tr></table></div><p>

      Where the input parameters are:

      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">initiating_dom</span></td><td><p>registered
        name of the initiating
        domain</p></td></tr><tr><td><span class="term">ee_key_letters</span></td><td><p>key
        letters of the external entity in the initiating
        domain</p></td></tr><tr><td><span class="term">recipient_domain</span></td><td><p>registered
        name of the recipient domain</p></td></tr></tbody></table></div><p>
      </p><div class="example"><a id="id2472207"></a><p class="title"><b>Example 4.3. Wiring Between xtUML Domains</b></p><pre class="programlisting">
.invoke WireSynchServiceOoaBridge( "HOME", "AWAY_EE", "AWAY" )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2472222"></a>Wiring an xtUML Bridge Using FBOs</h4></div></div></div><p>Use this invocation to declare the interface between two
      xtUML domains using a bridge object.  [Note that this marking
      option is provided for backwards compatibility reasons only.
      Domain function (synchronous services) should be used for
      all bridging purposes.]
      The term <span class="emphasis"><em>initiating domain</em></span>
      refers to the xtUML domain which contains the external entity
      (EE) against which bridge calls to the recipient domain are
      made.  The term <span class="emphasis"><em>recipient domain</em></span> refers to
      the xtUML domain which contains the ``Funky Bridge Object''
      (FBO).  The FBO is a pseudo state model that provides the
      implementation interface for the EE in the initiating domain.
      </p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef"><b class="fsfunc">WireOoaBridge</b>(</code></td><td>string  </td><td><var class="pdparam">"init_dom"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"ee_key_letters"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"recip_domain"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"fbo_key_letters"</var><code>)</code>;</td></tr></table></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">init_dom</span></td><td><p>registered
        name of the initiating
        domain</p></td></tr><tr><td><span class="term">ee_key_letters</span></td><td><p>key
        letters of the external entity in the initiating
        domain</p></td></tr><tr><td><span class="term">recip_domain</span></td><td><p>registered
        name of the recipient domain</p></td></tr><tr><td><span class="term">fbo_key_letters</span></td><td><p>key
        letters of the funky bridge object (FBO) in the recipient
        domain</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2472338"></a><p class="title"><b>Example 4.4. Wiring Between xtUML Domains Using Bridge Object</b></p><pre class="programlisting">
.invoke WireOoaBridge( "HOME", "AWAY_EE", "AWAY", "AWAY_FBO" )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2472354"></a>Wiring xtUML and Realized Domains</h4></div></div></div><p>Use this invocation to declare the interface between
      an xtUML domain and realized (non-xtUML) domain.  MC-3020 will
      generate an interface framework source file that represents
      a compilable definition of the implementation interface.  This
      bridge skeleton will be generated into
      the <tt class="filename">system/skel</tt> directory.  It can be
      copied to the <tt class="filename">system/user/source</tt> directory
      and modified (if desired) to invoke user supplied code.
      </p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef"><b class="fsfunc">WireRealizedExternalEntity</b>(</code></td><td>string  </td><td><var class="pdparam">"ooa_domain_name"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"ee_key_letters"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"realized_domain_name"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"method_prefix"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"include_file"</var><code>)</code>;</td></tr></table></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">ooa_domain_name</span></td><td><p>registered
        name of xtUML domain (``*'' means any
        domain.)</p></td></tr><tr><td><span class="term">ee_key_letters</span></td><td><p>key
        letters of the external entity in the xtUML
        domain</p></td></tr><tr><td><span class="term">realized_domain_name</span></td><td><p>registered
        name of realized domain</p></td></tr><tr><td><span class="term">method_prefix</span></td><td><p>prefix
        to be prepended to the bridge process method name used in the
        Nucleus BridgePoint action language</p></td></tr><tr><td><span class="term">include_file</span></td><td><p>name
        of the header file to include for the realized
        domain</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2472477"></a><p class="title"><b>Example 4.5. Wiring a Realized Domain</b></p><pre class="programlisting">
.invoke WireRealizedExternalEntity("ODMS", "PIO", "PIO", "PIO", "PIO_bridge.h")
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2472493"></a>Marking xtUML-Realized Bridges</h4></div></div></div><p>As of version 5.0 of Nucleus BridgePoint Model Builder, domain functions make
      the cleanest interfaces between xtUML and non-xtUML domains.  Using
      domain functions for bridging is preferred over the previous
      (although still supported) bridge object strategy.  MC-3020
      will automatically generate interface declaration files into
      the <tt class="filename">system/skel</tt> directory for all domain
      functions in the system.  There is no requirement to mark the
      domain functions in any way, the declaration occurs automatically.
      Use these <tt class="filename">.h</tt> declaration
      files for inclusion into realized code
      to declare the signatures of interfaces into an xtUML domain(s).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2472534"></a>Marking a Bridge Safe for Interrupt Invocation</h4></div></div></div><p>MC-3020 allows domain function bridges
      to be marked as
      callable from interrupt handlers or other asynchronous
      sources (such as other tasks, signal handlers, etc).
      Synchronous services
      marked here will generate a short stub interface
      that will defer execution of the bridge to be between
      dispatched state actions.  When a domain function marked
      as safe for interrupts is invoked, its action body is
      posted to a queue for dispatch after any currently running
      state action completes.  This guarantees architecture
      data mechanism integrity while maintaining application data
      access set consistency.</p><p>Synchronous services marked safe for interrupts
      cannot return data.  They must be of return type void.
      However, core data type data
      can be passed into these domain functions.
      Such data is packaged safely at interrupt level and then
      unpacked in the bridge service.</p><p>To indicate to the model compiler that a domain
      function serves as
      a bridge operation which may be invoked in a manner safe for
      invocation from an interrupt handler or other asynchronous
      activation (one for each domain function):
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagSyncServiceSafeForInterrupts</b>(</code>string <var class="pdparam">"domain"</var>, string <var class="pdparam">"sync_service"</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">domain</span></td><td><p>registered
        xtUML domain name</p></td></tr><tr><td><span class="term">sync_service</span></td><td><p>is
        name of the domain function being tagged
        as safe for calling.</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2472625"></a><p class="title"><b>Example 4.6. Tagging Interrupt Bridges</b></p><pre class="programlisting">
.invoke TagSyncServiceSafeForInterrupts( "ILB", "kick_start" )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2472640"></a>Marking an FBO Safe for Interrupt Invocation</h4></div></div></div><p>MC-3020 allows "funky bridge objects" to be marked as
      callable from interrupt handlers or other asynchronous
      sources (such as other tasks, signal handlers, etc).
      This feature is available on bridge objects for continued
      support of now obsolete functionality.  Using domain
      functions for bridges is preferred.  Use of "funky bridge
      objects" is discouraged.</p><p>Bridge object actions marked safe for interrupts
      cannot return data.  They must be of return type void.
      Bridge object actions marked safe for interrupts cannot
      pass parameters.  Use synchronous services (domain functions)
      if passing data is desired.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2472675"></a>Enabling/Disabling Interrupts</h4></div></div></div><p>To protect data structures for Interrupt Safe Bridges,
      interrupts are disabled for a very few instructions.
      The method of disabling interrupts varies from target to
      target and from compiler to compiler.  Therefore, the
      responsibility of defining the specific flavor of EI/DI
      instruction is left to the user.  The marking functions
      <tt class="function">UserEnableInterrupts</tt> and
      <tt class="function">UserDisableInterrupts</tt> are
      are provided for specifying the specific way interrupts
      are enabled and disabled with your specific target.</p><p>To define the instruction sequence for enabling
      and disabling interrupts, edit the system-level user
      defined rule file <tt class="filename">sys_functions.arc</tt>.
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2472716"></a>Bit Fields</h4></div></div></div><p>Bit fields provide a means of packing many small
      value attributes into single words of computer storage.
      MC-3020 allows attributes to be stored as bit fields
      in ANSI C structs.</p><p>Attributes are marked with Nucleus BridgePoint Model Builder.  The string
      BIT_WIDTH: n is placed within a comment as the first line
      of the attribute description.  ``n'' is the width in
      bits required to store the attribute.</p><p>It should be understood that bit fields are
      inherently somewhat less portable than most other
      ANSI C constructs.  Dependence upon ``Endian-ness'',
      memory models and other compiler/target implementation
      specifics is not uncommon.  Use bit fields with care.</p><p>The maximum width for a bit field member attribute
      is 16 bits.  Bit field members are of type unsigned int.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2472762"></a>Fixing Class Extents</h4></div></div></div><p>MC-3020 provides a means of establishing the base
      memory address of class instance collections (extents).
      Within Nucleus BridgePoint Model Builder the string
      BASE_ADDRESS: n is placed within a comment as the first
      line of the class description.  ``n'' is the memory
      address anchoring the start of the collection of class
      instances.</p><p>Two user defined rule file functions at the system-level 
      define how this number (``n'') will appear in the generated
      code.  One function (<tt class="function">UserFixExtentBaseBegin</tt>)
      is used to insert code before the definition of the class
      instance collection memory.  Another function
      (<tt class="function">UserFixExtentBaseEnd</tt>) is used to 
      insert code directly after the data definition.  This
      combination of functions will allow a <span><b class="command">pragma</b></span>
      around the data definition.</p><p>To define the instruction sequence for fixing the
      class extent, edit the system-level user
      defined rule file <tt class="filename">sys_functions.arc</tt>.
      </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2472815"></a>Specifying Data Types, Precision and Enumerators</h3></div></div></div><p>Nucleus BridgePoint allows the user to define special data
    types.  Marking is used to define the precision of these data
    types.  This is particularly useful to reduce the storage
    (say from 16 or 32 bits to 8 bits) of class attributes when
    the ranges of the attributes are known to be limited.
    User defined types which are also enumerations are included
    in the category of types that can be controlled.
    The <tt class="filename">datatype.clr</tt> provides the means
    for specifying these data type specializations.</p><p>Note that core types can be marked with this function as
    well as user defined types (UDTs).  For example, the core type real
    can be marked to generate "double" precision.</p><p>The return data type for bridges and operations
    can be user defined data types.  Empty operations can be
    used as a sort of variable declaration in conjunction with
    UDT precision tagging.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2472856"></a>Tagging Precision</h4></div></div></div><p>Mark <tt class="function">TagDataTypePrecision</tt> may only be
      used for application analysis data types which are derived from
      either Nucleus BridgePoint core data types of <span class="type">integer</span> or
      <span class="type">real</span>.
      Also, user defined types that are enumerations
      can be marked.  Such data will have core data type
      <span class="type">string</span>, but will serve as integers.
      Attempting to use this mark with any other
      core data type will result in a fatal marking error
      (translation aborted).  This restriction applies equally to
      both domain specific and system wide use of this mark.</p><p>Precision tag  <i class="parameter"><tt>tagged_name</tt></i> may be
      any standard C/C++ integer or real variable type.  For
      example, <span class="type">unsigned char</span>, <span class="type">long long</span>,
      <span class="type">double</span>, etc.  POSIX types are also accepted, such
      as <span class="type">uchar_t</span>, <span class="type">ulong_t</span>, etc.</p><p>When an analysis class is instantiated, the default is
      to initialize attributes of core type <span class="type">integer</span> to
      0, and attributes of core type <span class="type">real</span> to 0.0
      (declared as code type <span class="type">float</span>).  Tag
       <i class="parameter"><tt>initial_value</tt></i> may be used to re-define
      the default initialization value.</p><p>Casting may be used in the tag, such as
       <i class="parameter"><tt>"(unsigned)EACCESS"</tt></i>, but should be used
      only with careful system level discretion.</p><p>No translation time error checking is performed on
       <i class="parameter"><tt>initial_value</tt></i>.  Bogus tags such as
       <i class="parameter"><tt>"@*#$"</tt></i> will only be caught during
      compilation.</p><p>Invoke <tt class="function">TagDataTypePrecision</tt> to
      indicate to the model compiler the precision of a user defined
      data type defined in the Nucleus BridgePoint Subsystem Partitioning Model
      (SPM) domain data editor.
      </p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef"><b class="fsfunc">TagDataTypePrecision</b>(</code></td><td>string  </td><td><var class="pdparam">"domain"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"dt_name"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"tagged_name"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"initial_value"</var><code>)</code>;</td></tr></table></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">domain</span></td><td><p>registered
        domain name (Use ``*'' to indicate a system wide data type to
        be applied to all domains containing the user data
        type.)</p></td></tr><tr><td><span class="term">dt_name</span></td><td><p>name of the
        data type as known in the application
        analysis</p></td></tr><tr><td><span class="term">tagged_name</span></td><td><p>name of
        the data type as known in generated implementation code
        (e.g. the precision of the data
        type)</p></td></tr><tr><td><span class="term">initial_value</span></td><td><p>
        optional specification of the default value for the data
        type (Use "" for the architectural default (e.g. 0 for
        integer, 0.0 for real.)</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2473074"></a><p class="title"><b>Example 4.7. Data Type Precision</b></p><pre class="programlisting">
.invoke TagDataTypePrecision( "MyDom", "Octet", "uchar_t", "" )
.invoke TagDataTypePrecision( "MyDom", "FunkyReal", "double", "666.999" )
.invoke TagDataTypePrecision( "*", "SysWideLong", "long int", "-1" )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2473090"></a>Mapping Pointer Types</h4></div></div></div><p>To allow for pointer reference to arbitrarily shaped
      masses of data, user-defined data types can be implemented
      as pointers.  After marking a UDT as a pointer, the pointer
      typed data can be passed into and returned from operation
      and bridge operations.
      Marking is used to tag pointer types.
      The <tt class="filename">datatype.clr</tt> provides the means
      for specifying these pointer data type specializations.</p><p>Invoke <tt class="function">MapDataTypeAsPointer</tt> to
      indicate to the model compiler that a user defined
      data type defined in the Nucleus BridgePoint Subsystem Partitioning Model
      (SPM) domain data editor shall be implemented as a pointer.
      </p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef"><b class="fsfunc">MapDataTypeAsPointer</b>(</code></td><td>string  </td><td><var class="pdparam">"domain"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"dt_name"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"pointer_type"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"include_file"</var><code>)</code>;</td></tr></table></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">domain</span></td><td><p>registered
        domain name (Use ``*'' to indicate a system wide data type to
        be applied to all domains containing the user data
        type.)</p></td></tr><tr><td><span class="term">dt_name</span></td><td><p>name of the
        data type as known in the application
        analysis</p></td></tr><tr><td><span class="term">pointer_type</span></td><td><p>name of
        the pointer data type as known in generated implementation code.
        </p></td></tr><tr><td><span class="term">include_file</span></td><td><p>
        optional include file which declares the implementation type
        of `pointer_type'.</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2473212"></a><p class="title"><b>Example 4.8. Mapping Pointer Types</b></p><pre class="programlisting">
.invoke MapDataTypeAsPointer( "MyDom", "DataPacket", "char", "" )
.invoke MapDataTypeAsPointer( "DomA", "AcmeType", "SomeStruct_t", "legacy.h" )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="SpecifyingUnitialized-section"></a>Specifying Uninitialized
      Enumerators</h4></div></div></div><p>In analysis models, enumerated types defined within Nucleus BridgePoint Model Builder
      (using the Data Type editor available in BP5.0+) have no initial
      (uninitialized) value.  With marking, it is possible to
      explicity define this value for uninitialized enumeration
      variables.  The <tt class="filename">datatype.clr</tt> provides the
      means for specifying this starting value.</p><p>To indicate to the software architecture that the
      uninitialized enumerator of an enumeration (defined in the
      Nucleus BridgePoint Subsystem Partitioning Model (SPM) domain data editor)
      shall have a value other than the default, use the following
      invocation:
      </p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef"><b class="fsfunc">TagUninitializedEnumerationValue</b>(</code></td><td>string  </td><td><var class="pdparam">"domain"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"enumeration"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"value"</var><code>)</code>;</td></tr></table></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">domain</span></td><td><p>registered
        domain name (Use ``*'' to indicate a system wide data type to
        be applied to all domains containing the enumeration data
        type.)</p></td></tr><tr><td><span class="term">enumeration</span></td><td><p>is the
        name of the enumration data type as known in the application
        analysis.  Use ``*'' to indicate <span class="emphasis"><em>all</em></span>
        enumerations domain or system wide.</p></td></tr><tr><td><span class="term">value</span></td><td><p>a string
        containing the value to be assigned to the unitialized
        enumerator</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2473342"></a><p class="title"><b>Example 4.9. Specifying a Value for the Default Uninitialized
        Enumerator</b></p><p>
        Domain specific:
        </p><pre class="programlisting">
.invoke TagUninitializedEnumerationValue( "MO", "wattage", "4" )
        </pre><p>
        All Enumerations in Domain:
        </p><pre class="programlisting">
.invoke TagUninitializedEnumerationValue( "MO", "*", "0x40" )
        </pre><p>
        System Wide:
        </p><pre class="programlisting">
.invoke TagUninitializedEnumerationValue( "*", "wattage", "0x20" )
        </pre><p>
        All Enumerations in All Domains:
        </p><pre class="programlisting">
.invoke TagUninitializedEnumerationValue( "*", "*", "100" )
        </pre><p>
        </p></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="SpecifyingEnumValues-section"></a>Specifying Values
      for Enumerators</h4></div></div></div><p>In some target environments, it may be desirable to
      select the integer values of the individual enumerators in
      an enumeration.  MC-3020 enables the assigning of discrete
      values to one or more of the enumerators in an enumeration.
      </p><p>Invoke <tt class="function">TagEnumeratorDiscreteValue</tt> to
      indicate to the model compiler that a user defined enumeration data
      type enumerator (defined in the Nucleus BridgePoint Subsystem Partitioning
      Model (SPM) domain data editor) shall have a value other than the
      default.
      </p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef"><b class="fsfunc">TagEnumeratorDiscreteValue</b>(</code></td><td>string  </td><td><var class="pdparam">"domain"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"enumeration"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"enumerator"</var>, </td></tr><tr><td> </td><td>string  </td><td><var class="pdparam">"value"</var><code>)</code>;</td></tr></table></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">domain</span></td><td><p>registered
        domain name (Use ``*'' to indicate a system wide data type to
        be applied to all domains containing the enumeration data
        type.)</p></td></tr><tr><td><span class="term">enumeration</span></td><td><p>is the
        name of the enumration data type as known in the application
        analysis.  Use ``*'' to indicate <span class="emphasis"><em>all</em></span>
        enumerations domain or system wide.</p></td></tr><tr><td><span class="term">value</span></td><td><p>a string
        containing the value to be assigned to the specified
        enumerator</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2473500"></a><p class="title"><b>Example 4.10. Specifying Enumerator Values</b></p><p>
        Domain specific:
        </p><pre class="programlisting">
.invoke .invoke TagEnumeratorDiscreteValue( "MO", "wattage", "low", "4" )
.invoke TagEnumeratorDiscreteValue( "MO", "wattage", "med", "0x20" )
        </pre><p>
System Wide:
        </p><pre class="programlisting">
.invoke TagEnumeratorDiscreteValue( "*", "wattage", "high", "0x40" )
        </pre><p>
        </p></div><p>
      </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2473531"></a>System Level Marks</h3></div></div></div><p>There are characteristics of the system as a whole that
    may need to be controlled during translation.  Several
    constants define resource allocation and generation constraints.
    Some constants allow for ``tweaking'' the system to obtain
    optimal performance in terms of size or speed.  These 
    constants can be marked as the system architect desires.</p><p>Marking at the system level is provided by a set of
    marking files in the <tt class="filename">system</tt> directory
    in the build area.  The file
    <tt class="filename">system.clr</tt> provides the means for specifying
    these system constants.</p><p>Within system marking, the flavor of collection
    containers can be specified.  Different collection flavors
    provide optimizations for space or speed.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="Marking-EnablingTasking-section"></a>Enabling
      Multi-Tasking</h4></div></div></div><p>MC-3020 provides for tasking/threading using the
        capabilities of the target operating system (OS) or real-time
        operating system (RTOS).  An example of an RTOS is the Nucleus
        PLUS real-time operating system.  </p><p>To cause MC-3020 to generate multi-tasking/threading code,
        invoke the following marking function.  Pass it arguments that
        specify the type of multi-tasking environment and whether or not
        to serialize all action processing (across all tasks).</p><p>To enable tasking in the generated system:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">EnableTasking</b>(</code>string <var class="pdparam">flavor</var>, string <var class="pdparam">serialization</var>, integer <var class="pdparam">tasks</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">flavor</span></td><td><p>is the
        type of tasking environment being integrated (such as "POSIX" or
        "Nucleus").
        </p></td></tr><tr><td><span class="term">serialization</span></td><td><p>is set
        to "serialize" to force all action across all tasks to be run
        sequentially.  Note that serializing the action processing
        reduces data access contention, but can severely reduce the 
        multi-tasking performance of the generated system.
        </p></td></tr><tr><td><span class="term">tasks</span></td><td><p>is the
        number of tasks/threads in the xtUML generated system.
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2473681"></a><p class="title"><b>Example 4.11. Enabling Tasking/Threading</b></p><pre class="programlisting">
.invoke EnableTasking( "Nucleus", "", 4 )
.invoke EnableTasking( "POSIX", "serialize", 2 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="Marking-TaskPriority-section"></a>Establishing Multi-Task Priority</h4></div></div></div><p>Some flavors of tasking/threading allow for differing
        execution priorities of tasks or threads.
        MC-3020 allows the priorities of tasks to be set through
        marking.
        In systems that support explicit prioritization of tasks,
        each task (of the number specified in
        <tt class="function">EnableTasking</tt>) can
        have a priority assigned.  Use the following marking function
        to set the priority for each task.</p><p>To specify the priorities of tasks/threads:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">SetTaskPriority</b>(</code>integer <var class="pdparam">task_number</var>, string <var class="pdparam">priority</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">task_number</span></td><td><p>is the
        number of the task starting with zero and going to one less
        than the number specified in <tt class="function">EnableTasking</tt>.
        </p></td></tr><tr><td><span class="term">priority</span></td><td><p>is a string
        representing the priority level of the task.  The string type
        of this argument allows for symbolic as well as numeric
        representation of task priority.  This representation will be a
        function of the tasking environment being integrated.
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2473785"></a><p class="title"><b>Example 4.12. Setting Task/Thread Priority</b></p><pre class="programlisting">
.invoke SetTaskPriority( 0, "100" )
.invoke SetTaskPriority( 3, "high" )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2473800"></a>Maximum String Size</h4></div></div></div><p>MC-3020 tries to use relatively safe methods of
      manipulating strings.  The ``n'' library functions are used
      (<tt class="function">strncpy, strncpy, strncat</tt>) rather than
      their more dangerous (as regards buffer overruns) counterparts.</p><p>To specify the maximum length of a string in the system:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagMaximumStringLength</b>(</code>integer <var class="pdparam">max_len</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">max_len</span></td><td><p>is the
        longest string that will be manipulated by the system.
        Truncation will occur beyond this length.
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2473856"></a><p class="title"><b>Example 4.13. Defining String Length</b></p><pre class="programlisting">
.invoke TagMaximumStringLength( 16 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2473871"></a>Controlling Collection Sizes</h4></div></div></div><p>Sets of instances are collected for various AL
      operations.  Relationships with multiplicity MANY require
      set container mechanisms at the implementation level to
      manage the collection of related instances.  The maximum
      number of instances allowed in such collections can be
      controlled with a mark.</p><p>To specify the maximum ``relationship extent'' size
      in the system:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagMaximumRelationshipExtentSize</b>(</code>integer <var class="pdparam">value</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">value</span></td><td><p>represents
        the highest number of instances allowed in a MANY
        relationship.</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2473927"></a><p class="title"><b>Example 4.14. Max Relationship Extent</b></p><pre class="programlisting">
.invoke TagMaximumRelationshipExtentSize( 8 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2473942"></a>Managing Selection Collections</h4></div></div></div><p>Another operation requiring set manipulation is a
      selection (SELECT MANY) that may result in a collection of multiple
      instances.</p><p>To specify the maximum ``selections extent'' size
      in the system:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagMaximumSelectionExtentSize</b>(</code>integer <var class="pdparam">value</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">value</span></td><td><p>represents
        number of containers that will be pre-allocated for AL
        SELECT statements.</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2473993"></a><p class="title"><b>Example 4.15. Max Selections Extent</b></p><pre class="programlisting">
.invoke TagMaximumSelectionExtentSize( 12 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2474007"></a>Changing the Flavor of Collections</h4></div></div></div><p>Collections are maintained with a mechanism of one type
      or another.  With this mark, the type desired for a particular
      translation can be specified.  The default is singly linked list
      container nodes.  Doubly linked list containers can be selected
      as flavor 20.  Doubly linked lists allow for faster deletion of
      instances in exchange for an additional pointer size (for ``prev'')
      per container in the system.</p><p>To specify the flavor of the collection nodes:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagCollectionsFlavor</b>(</code>integer <var class="pdparam">value</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">value</span></td><td><p>a numerical
        representation of a specific type and strategy of collections
        container.</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2474064"></a><p class="title"><b>Example 4.16. Collection Node Type Selection</b></p><pre class="programlisting">
.invoke TagCollectionsFlavor( 20 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2474079"></a>Limiting/Extending Event Queues</h4></div></div></div><p>MC-3020 attempts to dynamically calculate reasonable
      and safe values for queue depths within the event generation
      and delivery mechanism.  However, for optimization purposes
      the user may wish to override these values.</p><p>To override the compiler calculated maximum queue
      depth for the self directed event queue:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagMaximumSelfDirectedEvents</b>(</code>integer <var class="pdparam">value</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">value</span></td><td><p>which
        is the hard-coded depth of the self-directed event queue.
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2474130"></a><p class="title"><b>Example 4.17. Self-Directed Queue Depth</b></p><pre class="programlisting">
.invoke TagMaximumSelfDirectedEvents( 3 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2474145"></a>Limiting/Extending NonSelf Queue</h4></div></div></div><p>To override the compiler calculated maximum queue
      depth for the instance directed event queue:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagMaximumNonSelfDirectedEvents</b>(</code>integer <var class="pdparam">value</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">value</span></td><td><p>which
        is the hard-coded depth of the non- self-directed event queue.
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2474189"></a><p class="title"><b>Example 4.18. Instance Directed Queue Depth</b></p><pre class="programlisting">
.invoke TagMaximumNonSelfDirectedEvents( 5 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2474204"></a>Timer Queue</h4></div></div></div><p>A mark is provided so the system analyst can direct
      the model compiler to increase or decrease the timer queue
      used to manage multiple pending xtUML timers (delayed events).
      To override the compiler calculated queue
      depth for pending xtUML timers:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagMaximumPendingOoaTimers</b>(</code>integer <var class="pdparam">value</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">value</span></td><td><p>represents
        is the hard-coded maximum number of timers that may be pending
        expiration at any point in time.</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2474254"></a><p class="title"><b>Example 4.19. Pending xtUML Timers</b></p><pre class="programlisting">
.invoke TagMaximumPendingOoaTimers( 6 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2474268"></a>Interleaved Bridges</h4></div></div></div><p>Use this mark to expand or reduce the depth of the queue used
      to interleave ``asynchronous'' bridge operations between state
      actions.  The default will be a system divined value that should
      be relatively safe in most cases.</p><p>To hard-code the depth of the interleaved bridges queue:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagMaximumInterleavedBridges</b>(</code>integer <var class="pdparam">value</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">value</span></td><td><p>represents
        the maximum queue depth for safe bridge operations that
        are interleaved between state actions (to maintain data access
        set consistency).</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2474323"></a><p class="title"><b>Example 4.20. Interleaved Bridges Queue Depth</b></p><pre class="programlisting">
.invoke TagMaximumInterleavedBridges( 4 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2474337"></a>Interleaved Bridge Data</h4></div></div></div><p>Use this mark to define how many bytes of argument data
      come in across an interleaved bridge operation.  The default is 8.
      </p><p>To hard-code the width of the interleaved bridge argument path:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagInterleavedBridgeDataSize</b>(</code>integer <var class="pdparam">value</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">value</span></td><td><p>represents
        the maximum number of bytes of arguments that an interleaved
        bridge may receive during an invocation.
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2474388"></a><p class="title"><b>Example 4.21. Interleaved Bridge Argument Data</b></p><pre class="programlisting">
.invoke TagInterleavedBridgeDataSize( 2 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="DebuggerMark-section"></a>Marking On Model Debugger</h4></div></div></div><p>This mark works in conjunction with the Nucleus BridgePoint Model Debugger.  By invoking
      this marking interface, target debug code is generated.  Note
      that a significant amount of tooling code is generated in line
      with functional code.  A debug version of the target image will
      run successfully on the development host computer or a socket-
      capable target with sufficient memory (RAM).
      </p><p>To enable the generation of debug code for use with Nucleus BridgePoint Model Debugger:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagModelDebuggingOn</b>(</code><code>void)</code>;</p></div><p>
      
      </p><div class="example"><a id="id2471640"></a><p class="title"><b>Example 4.22. Enabling Model Debug Code</b></p><p>
        </p><pre class="programlisting">.invoke TagModelDebuggingOn()</pre><p>
        </p></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="PeristenceCacheDepth-section"></a>Marking Persistence
      Cache Queue Depth</h4></div></div></div><p>This mark is used to specify the maximum number of instances and
      links that can be queued waiting to be flushed to non-volatile
      storage (NVS).  As instances and links become "dirty" they get
      queued to NVS.  When PERSIST::Commit is called these queues are flushed.
      </p><p>To change the default depth (128) to something different:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">MarkPersistenceCacheDepth</b>(</code>integer <var class="pdparam">instance_depth</var>, integer <var class="pdparam">link_depth</var><code>)</code>;</p></div><p>

      Where the argument:

      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">instance_depth</span></td><td><p>is
        the number of instances that can be queued waiting to be flushed
        to non-volatile storage (NVS).
        </p></td></tr><tr><td><span class="term">link_depth</span></td><td><p>is
        the number of links that can be queued waiting to be flushed
        to non-volatile storage (NVS).
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2471736"></a><p class="title"><b>Example 4.23. Changing Persistence Cache Queue Depth</b></p><p>
        </p><pre class="programlisting">.invoke MarkPersistenceCacheDepth( 16, 32 )</pre><p>
        </p><pre class="programlisting">.invoke MarkPersistenceCacheDepth( 1000, 500 )</pre><p>
        </p></div><p>
      </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2471756"></a>Domain Specializations</h3></div></div></div><p>Within MC-3020 domain level customizations can be
    applied.  The marking file
    <tt class="filename">domain.clr</tt> is the place to tag
    the customizations.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2474720"></a>Identifying Initialization Functions</h4></div></div></div><p>Initialization functions provide the analyst a means
      to specify preexisting instances for production
      bring-up.  They also serves to set up test scenarios.
      Domain functions also can be activated/deactivated with marking.
      Use domain functions instead of initialization objects.
      Through marking, specific initialization functions can be
      chosen for system bring-up while others are marked (or erased
      as the case may be) as not to be translated.</p><p>Marking a function for initialization does not change
      the function.  The function remains available for invocation
      by any of the action semantics that could normally call it.
      If more than one function is tagged as an initialization function,
      each will be invoked.  The order of invocation is alphabetical
      by function name.</p><p>Identify a function in the domain to be used as the an
      initialization function by invoking the following rule file
      function in the <tt class="filename">domain.clr</tt> marking file.
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagInitializationFunction</b>(</code>string <var class="pdparam">"function_name"</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">function_name</span></td><td><p>is
        the name of the domain function (synchronous service) to be
        invoking during bring-up.
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2474796"></a><p class="title"><b>Example 4.24. Tagging Initialization Functions</b></p><p>
        </p><pre class="programlisting">
.invoke TagInitializationFunction( "CreateAndPopulate" )
        </pre><p>
        </p></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2474815"></a>Identifying Initialization Objects</h4></div></div></div><p>Initialization objects represent an obsolete (although
      still supported) means for the analyst to specify preexisting
      instances for production bring-up.
      All of the functionality of the obsolete
      <tt class="function">TagInitializationFunction</tt>
      is now provided in domain functions
      which can activated/deactivated and marked for initialization.
      Use domain functions instead of initialization objects.
      See <tt class="function">TagInitializationFunction</tt>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2474841"></a>Excluding Classes</h4></div></div></div><p>MC-3020 can be directed to skip code generation for
      classes marked with the
      <tt class="function">TagExcludeObjectFromCodeGen</tt>
      invocation.  Combined with selective marking of initialization
      functions, class exclusion allows for a simple method of
      providing multiple bring-up scenarios.  Exclude a class from
      code generation by marking it thusly:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagExcludeObjectFromCodeGen</b>(</code>string <var class="pdparam">"key_letters"</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">key_letters</span></td><td><p>key
        letters of the excluded
        class</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2474892"></a><p class="title"><b>Example 4.25. Tagging Excluded Classes</b></p><p>
        </p><pre class="programlisting">
.invoke TagExcludeObjectFromCodeGen( "TST_OBJ" )
        </pre><p>
        </p></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2474910"></a>Excluding Subsystems</h4></div></div></div><p>To indicate to the model compiler that all classes
      in a specified subsystem should be excluded from implementation
      code generation, use the following invocation (one for each
      excluded subsystem):
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagExcludeSubsystemFromCodeGen</b>(</code>string <var class="pdparam">"subsystem"</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">name</span></td><td><p>name
        of the excluded subsystem</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2474954"></a><p class="title"><b>Example 4.26. Tagging Excluded Subsystems</b></p><p>
        </p><pre class="programlisting">
.invoke TagExcludeSubsystemFromCodeGen( "MyVerifierUnitTests" )
        </pre><p>
        </p></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2474973"></a>Disabling Function Translation</h4></div></div></div><p>To indicate to the model compiler that the semantic
      action of a function should not be translated, mark the
      function with the <tt class="function">TagFunctionTranslationOff</tt>
      marking function.  This is useful for selectively disabling
      functions used to set up test scenarios.  This is also key
      for disabling initialization functions after preexisting
      instances have been created and saved in XML data.
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagFunctionTranslationOff</b>(</code>string <var class="pdparam">"function_name"</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">function_name</span></td><td><p>name
        of the excluded function (synchronous
        service)</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2475025"></a><p class="title"><b>Example 4.27. Not Translating a Function</b></p><p>
        </p><pre class="programlisting">
.invoke TagFunctionTranslationOff( "CreateRelateInit" )
.invoke TagFunctionTranslationOff( "TestScenarioFive" )
        </pre><p>
        </p></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2475045"></a>State Transition Trace</h4></div></div></div><p>To instruct the model compiler to generate
      state transition tracing information, invoke the
      following rule file function:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagStateTransitionTracingOn</b>(</code><code>void)</code>;</p></div><p>
      
      no input arguments

      </p><div class="example"><a id="id2475071"></a><p class="title"><b>Example 4.28. Enabling State Transition Tracing</b></p><p>
        </p><pre class="programlisting">
.invoke TagStateTransitionTracingOn()
        </pre><p>
        </p></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2475089"></a>Action Language Trace</h4></div></div></div><p>To instruct the model compiler to generate
      tracing information at the action language statement
      level, invoke the following rule file function:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagActionStatementTracingOn</b>(</code><code>void)</code>;</p></div><p>
      
      no input arguments

      </p><div class="example"><a id="id2475115"></a><p class="title"><b>Example 4.29. Enabling Action Language Tracing</b></p><pre class="programlisting">
.invoke TagActionStatementTracingOn()
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2475130"></a>Empty Handle Usage</h4></div></div></div><p>It is possible to develop xtUML models that incorrectly attempt
      to use instance reference variables that are empty (null).  This
      can occur under several sets of circumstances.  For example,
      selection across a conditional relationship chain may return
      an empty instance reference or empty instance reference set.
      Using such a reference without testing for empty can lead to
      an invalid operation.  (MC-3020 does not enforce relationship
      conditionality at model compilation time.)  It is possible
      to build models that attempt to send events to empty instance
      references, or relate or unrelate (link/unlink) instance when
      one or both references are empty.</p><p>MC-3020 provides a markable debug option for detecting
      and potentially recovering from such empty ``handle'' references.
      To steer the model compiler into generating debug code that
      detects the use of empty instance references and instance set
      references (handles), invoke the following rule file function:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagEmptyHandleDetectionOn</b>(</code><code>void)</code>;</p></div><p>
      
      no input arguments

      </p><div class="example"><a id="id2475184"></a><p class="title"><b>Example 4.30. Enabling Empty Reference Usage Detection</b></p><pre class="programlisting">
.invoke TagEmptyHandleDetectionOn()
        </pre></div><p>
      </p><p>MC-3020 will generate detection code and invoke a
      macro when an improper handle usage is detected.  The
      macro defaults to invocation of a user callout function,
      <tt class="function">UserEmptyHandleDetectedCallout</tt>.
      The body of this callout function can be (re)defined by
      the user.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2475212"></a>Disabling First Pass Optimizations</h4></div></div></div><p>At times it is necessary to carefully study the
      generated code.  This may be the case when enhancing or extending
      the default functionality of MC-3020.  Under such circumstances,
      it may be desirable to see the code in its
      <span class="emphasis"><em>un</em></span>optimized format.  Note that MC-3020 has
      several optimizations that eliminate unused code.  During design,
      sometimes it is desirable to see what this unused code looks
      like.  Using <tt class="function">TagFirstPassOptimizationsOff()</tt>,
      it is possible to force MC-3020 to generate the code in its
      unoptimized form.</p><p>
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagFirstPassOptimizationsOff</b>(</code><code>void)</code>;</p></div><p>
      
      no input arguments

      </p><div class="example"><a id="id2475264"></a><p class="title"><b>Example 4.31. Forcing Generation Non-Optimal Code</b></p><pre class="programlisting">
.invoke TagFirstPassOptimizationsOff()
        </pre></div><p>
      </p><p>MC-3020 will generate all code, even if it is
      not expected to be executed during normal operation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2475283"></a>Miscellaneous Domain Marking</h4></div></div></div><p>Additional marking adjustments are available
      in the <tt class="filename">domain.clr</tt> marking file.
      Marking options that manipulate the style and appearance
      of the generated code and that control optimizations
      can be enabled.  See documentation in the marking file
      for these detailed options.</p><p>Marking commands for these aesthetic purposes
      include:
      </p><div class="itemizedlist"><ul type="disc"><li><p>TagStateActionCommentBlocksEnabled()</p></li><li><p>TagStateActionStatementCommentsDisabled()</p></li><li><p>TagStateActionVariableNamesEnabled()</p></li><li><p>TagVerboseReflexivePhrasesEnabled()</p></li></ul></div><p>
      </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2475337"></a>Class Specializations</h3></div></div></div><p>MC-3020 provides several customizations that can be
    selected on a class boundary.  The
    <tt class="filename">object.clr</tt> provides the means for marking
    these class specializations.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="Marking-MappingClassesToTasks-section"></a>Mapping Classes to Tasks/Threads</h4></div></div></div><p>When running in a multi-tasking/threading environment
        the user can cause the generated code for xtUML classes to
        run in different tasks/threads.  This mappings is accomplished
        using the <tt class="function">MapClassToTask</tt> marking function.
        Note that mapping tightly coupled classes (where some classes
        frequently access instance data of the other classes) to different
        tasks can aggravate data synchronization issues.  Map closely
        coupled classes to the same task.</p><p>To map a class or set of classes to a particular task number:
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">MapClassToTask</b>(</code>string <var class="pdparam">ss_name</var>, string <var class="pdparam">class_key_letters</var>, integer <var class="pdparam">task_number</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">ss_name</span></td><td><p>
        name of subsystem
        </p></td></tr><tr><td><span class="term">class_key_letters</span></td><td><p>
        keyletters of the class being mapped
        </p></td></tr><tr><td><span class="term">task_number</span></td><td><p> is
        the number (starting with 0) of the task to which the indicated
        class (or classes) is assigned
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2475451"></a><p class="title"><b>Example 4.32. Mapping Classes to Tasks</b></p><pre class="programlisting">
.// NOTES:
.// (1) To map a specific class, use "" for "ss_name"
.//     and provide the class key letters in "class_key_letters".
.// (2) To map all classes in the subsystem to the given task, provide
.//     the subsystem name for "ss_name" and "*" for the "class_key_letters".
.// (3) To mark all classes in the domain as mapped to a task, use "*"
.//     for "ss_name" and "class_key_letters".
.//
.invoke MapClassToTask( "", "MP", 1 )
.invoke MapClassToTask( "TRACKING", "*", 3 )
.invoke MapClassToTask( "*", "*", 0 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2475478"></a>Extent Sizes</h4></div></div></div><p>MC-3020 has limited the use of memory allocation.
      For memory constrained systems it is convenient to limit the
      number of instances of a class that can exist at any one
      time.  The following rule file function invocation will define
      that maximum number of instances that will ever be allocated
      for the given class.
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagObjectExtentSize</b>(</code>string <var class="pdparam">"key_letters"</var>, integer <var class="pdparam">value</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">key_letters</span></td><td><p>key
        letters of the class</p></td></tr><tr><td><span class="term">value</span></td><td><p>maximum
        number of instances</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2475543"></a><p class="title"><b>Example 4.33. Tagging Max Instances</b></p><pre class="programlisting">
.invoke TagObjectExtentSize( "FRODO", 20 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2475558"></a>Default Extent Size</h4></div></div></div><p>Early in the development cycle it may not be clear what
      the maximum number of instances of particular classes may be.
      MC-3020 provides a way to establish a default extent size to
      be used for all classes that do not explicitly define the
      maximum.
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagSystemObjectDefaultExtentSize</b>(</code>integer <var class="pdparam">value</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">value</span></td><td><p>default size
        for non-marked classes
        extents</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2475606"></a><p class="title"><b>Example 4.34. Tagging Default Extent</b></p><pre class="programlisting">
.invoke TagSystemObjectDefaultExtentSize( 24 )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2475621"></a>Enabling Preexisting Instances</h4></div></div></div><p>Version 3.1 of MC-3020 supports defining preexisting
      instances in data.  This saves the time and space overhead of
      initialization objects.  Mark all classes that have instances
      pre-defined in data.</p><p>Use this mark to enable the generation of ANSI C structure
      initializers to pre-populate instance collections from supplied
      XML data.  There is no harm in marking a class as having preexisting
      instances in data even if it does not.  Such marking will have the
      effect of making the class eligible for population by preexisting
      instances defined in data.  All classes so marked will query for
      the existence of preexisting instances and will populate with
      them when defined.
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagPEIsDefinedInData</b>(</code>string <var class="pdparam">ss_name</var>, string <var class="pdparam">class_key_letters</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">ss_name</span></td><td><p>
        name of subsystem
        </p></td></tr><tr><td><span class="term">class_key_letters</span></td><td><p>
        keyletters of the class eligible for population by preexisting
        instances
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2475697"></a><p class="title"><b>Example 4.35. Marking Classes as Having PEIs Defined in Data</b></p><pre class="programlisting">
.invoke TagPEIsDefinedInData( "", "DOG" )
.invoke TagPEIsDefinedInData( "VET", "*" )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2475713"></a>Identifying Static Instance Populations</h4></div></div></div><p>Static instance populations are those instance populations
      to which additions or deletions are never made during system
      execution.  By marking a class as having a static instance
      population, error messages will be generated if action language
      tries to create or delete instances of the marked class.</p><p>Use this mark to mark a population as having a fixed
      and unchanging population of instances.
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagStaticInstancePopulation</b>(</code>string <var class="pdparam">ss_name</var>, string <var class="pdparam">class_key_letters</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">ss_name</span></td><td><p>
        name of subsystem
        </p></td></tr><tr><td><span class="term">class_key_letters</span></td><td><p>
        keyletters of the class having fixed extent
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2475787"></a><p class="title"><b>Example 4.36. Marking Classes with Static Instance Populations</b></p><pre class="programlisting">
.invoke TagStaticInstancePopulation( "", "EXP" )
.invoke TagStaticInstancePopulation( "LAB", "*" )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2475803"></a>Identifying Read Only Instance Populations</h4></div></div></div><p>Read only classes are those classes which cannot be
      dynamically written or related.
      By marking a class as read-only,
      error messages will be generated if action language
      tries to write or relate instances of the marked class.</p><p>Use this mark to mark a class as having a read-only
      instances.
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagReadOnly</b>(</code>string <var class="pdparam">ss_name</var>, string <var class="pdparam">class_key_letters</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">ss_name</span></td><td><p>
        name of subsystem
        </p></td></tr><tr><td><span class="term">class_key_letters</span></td><td><p>
        keyletters of the read-only class
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2475873"></a><p class="title"><b>Example 4.37. Marking Read-Only Classes</b></p><pre class="programlisting">
.invoke TagReadOnly( "", "BBALL" )
.invoke TagReadOnly( "GYM", "*" )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="markingpersistence-section"></a>Marking Persistence</h4></div></div></div><p>Persistent classes retain the values of their attributes
      across power cycles.  This includes the current state of
      active state machines.
      Newly created and updated classes are
      "backed up" to non-volatile storage.  At system start-up time,
      any classes stored in non-volatile storage are restored before
      other application initialization occurs.  Individual classes
      can be marked to be persistent.</p><p>Use this mark to mark a class as persistent.
      </p><div class="funcsynopsis"><p><code class="funcdef"> <b class="fsfunc">TagPersistentClass</b>(</code>string <var class="pdparam">ss_name</var>, string <var class="pdparam">class_key_letters</var><code>)</code>;</p></div><p>
      </p><div class="funcsynopsis"><p><code class="funcdef"> <b class="fsfunc">TagNonPersistentClass</b>(</code>string <var class="pdparam">ss_name</var>, string <var class="pdparam">class_key_letters</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">ss_name</span></td><td><p>
        name of subsystem
        </p></td></tr><tr><td><span class="term">class_key_letters</span></td><td><p>
        keyletters of the persistent class
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2475989"></a><p class="title"><b>Example 4.38. Marking (Non-) Persistent Classes</b></p><pre class="programlisting">
.// To mark as persistent a specific class, use "" for "ss_name"
.// and provide the class key letters in "class_key_letters".
.invoke TagPersistentClass( "", "MP" )

.// To mark all classes in the subsystem as persistent, provide
.// the subsystem name for "ss_name" and "*" for
.// the "class_key_letters".
.invoke TagPersistentClass( "TRACKING", "*" )

.// To mark all classes in the domain as persistent, use "*"
.// for "ss_name" and "class_key_letters".
.invoke TagPersistentClass( "*", "*" )

.// To mark as non-persistent a specific class that had previously
./  been marked as persistent, use "" for "ss_name" and
.// provide the class key letters in "class_key_letters".
.invoke TagNonPersistentClass( "", "ASN" )
        </pre></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2476021"></a>Translating Operation and Bridge AL</h4></div></div></div><p>As of version 4.2 of Nucleus BridgePoint Model Builder it is possible to
      translate the AL contained in bridge and operation
      descriptions.  This conveniently allows testing generated/compiled
      code in the same way it is tested on the Nucleus BridgePoint Model Verifier.  Operation
      (transformer) AL
      is translated unless marked off; Bridge descriptions
      are always translated and simply added to the skeletons.</p><p>As of version 3.1 of MC-3020, the
      <tt class="function">TagTransformerGeneration</tt> is obsolete and
      does nothing functional other than generate a message.</p><p>This mark formerly (before version MC-3020 3.1)
      enabled the generation of ANSI C source
      code from Action Language (AL) embedded in the
      descriptions of named operation(s).  AL is always translated
      unless marked off with the command
      <tt class="function">TagClassOperationTranslationOff</tt>.</p><p>To disable the translation of AL in class (or instance)
      based operations, use the following marking command.
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagClassOperationTranslationOff</b>(</code>string <var class="pdparam">class_keyletters</var>, string <var class="pdparam">operation name</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">class_keyletters</span></td><td><p>
        keyletters of the class with which operation is associated
        </p></td></tr><tr><td><span class="term">operation name</span></td><td><p>
        operation name for which to disable source generation
        </p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2476124"></a><p class="title"><b>Example 4.39. Not Translating Operations</b></p><pre class="programlisting">
.invoke TagClassOperationTranslationOff( "T", "Cooking_Initializing" )
        </pre></div><p>
      </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2476141"></a>Event Prioritization</h3></div></div></div><p>MC-3020 provides prioritization through the marking
    of events.  Events can be tagged to have priorities that
    accelerate the delivery of past events of lower priority
    that are currently outstanding.  This provides the user with
    a degree of control over the sequencing of xtUML threads of
    control within the system.
    <tt class="filename">event.clr</tt> provides the means for specifying
    these event prioritizations.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2476167"></a>Priority Events</h4></div></div></div><p>To indicate to the model compiler than an event
      is to be given a priority, use the following invocation
      (one for each priority event):
      </p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">TagPriorityEvent</b>(</code>string <var class="pdparam">"event_label"</var>, integer <var class="pdparam">value</var><code>)</code>;</p></div><p>
      
      Where the input parameters are:
      
      </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">"event_label"</span></td><td><p>is
        the name of the event (with number
        appended)</p></td></tr><tr><td><span class="term">value</span></td><td><p>is the
        relative priority of the event.  Legal values are 0 to 255
        inclusive.  0 is lowest and default.</p></td></tr></tbody></table></div><p>
      
      </p><div class="example"><a id="id2476226"></a><p class="title"><b>Example 4.40. Tagging a Priority Event</b></p><pre class="programlisting">
.invoke TagPriorityEvent( "CAR1", 4 )
        </pre></div><p>
      </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="Containoids-section"></a>MC-3020 Extent Prediction and Marking</h3></div></div></div><p>First pass translation collects statistics used to
    conservatively estimate the number of container nodes (containoids)
    required by the system.</p><p>There are three different uses for instance containoids:
    class extents, association extents and selection extents.
    Selection extents govern the total size of transient instance
    reference set variables in the actions.  This represents values
    in the variable type <span class="type">inst_ref_set</span>.
    The required number of containoids for each flavor is summed
    to provide the upper limit to total containers.
    </p><pre class="programlisting">#define SYS_MAX_CONTAINERS \
    ( SYS_MAX_OBJECT_EXTENT + SYS_MAX_RELATIONSHIP_EXTENT + SYS_MAX_TRANSIENT_EXTENT )</pre><p>SYS_MAX_OBJECT_EXTENT is a sum of all of the extent counts across
    all the domains of the system, which are sums of the class extents
    in each domain.  Each class extent is allocated to be the system
    default for class extents, a marked value of the system default
    or the marked value for the specific class.</p><p>Selection extents are calculated by multiplying the largest
    number of selects that can occur in any action by the largest extent
    of any class.  Thus allowing for the worst case action to select
    the largest class extent each time.  This value is set in
    SYS_MAX_TRANSIENT_EXTENT.
    </p><pre class="programlisting">transient containers = ( max selects ) * ( largest class extent )</pre><p>Association extents are allowed to be as big as they would
    need to be if all instances on the MANY side were always
    participating.  This value is set in SYS_MAX_RELATIONSHIP_EXTENT.
    </p><pre class="programlisting">association containoids = ( number of MANYs ) * ( largest class extent )</pre><p>The following marks govern these extent sizes:

    </p><div class="itemizedlist"><ul type="disc"><li><pre class="programlisting">TagObjectExtentSize( "key_letters", value )</pre></li><li><pre class="programlisting">TagSystemObjectDefaultExtentSize( value )</pre></li><li><pre class="programlisting">TagMaximumRelationshipExtentSize( value )</pre></li><li><pre class="programlisting">TagMaximumSelectionExtentSize( value )</pre></li></ul></div><p>
    
    See the proper sections in the MC-3020 Users Guide for details
    on these marking parameters.</p><p>Association extents refer to the sets of instances
    participating
    in a association with multiplicity MANY.  Sets built from
    linked lists are used to optimize traversal of associations with
    multiplicity MANY.  For example, in the following model,
    A 1---R1---* B,
    class B does not need an extent set; it simply needs a single
    pointer reference to the A instance.  The A instance however does
    need a set of instance references.  Such a set uses "containoids"
    to collect the B instances related to the A instance.
    MC-3020 calculates the worst case (biggest possible) association
    extent.</p><p>The extent can be marked to be smaller than the worst case
    maximum using TagMaximumRelationshipExtentSize.
    <span><b class="command">TagObjectExtentSize</b></span> will also have an effect on
    the calculated total.</p><p>If no extent size marking is supplied, MC-3020 will
    calculate a worst case for a model of a higher number of
    containers.  MC-3020 will see R1 and allow for all possible
    instances of B to participate with instances of A.  (This is the
    most important point!)</p><p>Another way to understand how MC-3020 calculates this maximum
    is as follows:
    </p><div class="orderedlist"><ol type="1"><li><p>Count the number of MANYs (---*) on a class
      diagram.</p></li><li><p> For each MANY (---*), add the maximum class
      extent on the MANY side (B above).</p></li><li><p>There are adjustments to be considered in the
      case of associative classes.</p></li></ol></div><p>
    This sum across all domains in the system will be the
    SYS_MAX_RELATIONSHIP_EXTENT.</p></div></div></div><div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="TranslationBuild-chapter"></a>Chapter 5. Translation and Build</h2></div></div></div><div class="highlights"><a id="TranslationBuild-chapter-high"></a><p>This chapter
explains the mechanics of turning xtUML models into C code using
MC-3020.  The build environment is composed of a set of shell
scripts and makefiles.  Step by step usage is provided.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2480303"></a>Files</h2></div></div></div><div class="highlights"><p>The translation process generates several
  files.  This section describes these files and provides
  instructions for their use.</p></div><p>The build environment is designed to be easily modified.
  The design approach exhibits an intention to avoid anticipating
  and mandating any rigid strategy in compilation/link/locate land.
  MC-3020 opted for flexible and modifiable.  Makefiles are
  generated from rule files.  A link script is generated.  Both can
  be tailored.  The link script is very easy to augment.  It
  already supports various linking/locating tool
  environments.</p><p>The generated files for a system reside in a directory
  structure referred to as the <span class="emphasis"><em>application node</em></span>.
  Inside the application node there is one directory per xtUML domain
  translated.  Each of these directories is referred to as a
  <span class="emphasis"><em>domain node</em></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2480920"></a>System Node</h3></div></div></div><p>The application node is created using the
    <span><b class="command">rox_init_node</b></span> command found in the
    MC-3020 <tt class="filename">bin</tt> directory.
    The application node is divided
    into two flavors of subdirectories that represent the division of
    the architecture oriented code and the application oriented code.
    The architecture code is stored into the subdirectory called
    <tt class="filename">system</tt>.  The application subdirectories are
    named according to their domain repository names.</p><p>The application node has a few files in its root.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2480956"></a>Makefile.user</h4></div></div></div><p>At the top of the application node are a few Makefiles.
    <tt class="filename">Makefile.user</tt> is important, because
    it is where customizations are made for the compiler,
    assembler and linker being used.  Edit <tt class="filename">Makefile.user</tt> 
    and follow the instructions in the prologue.  There will
    be a few variables there that must be set to establish
    the commands and options used during C source code compilation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2480984"></a>system</h4></div></div></div><p>The main system node directory is
    <tt class="filename">system</tt>.  The following
    subdirectories are found therein:</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2481000"></a>color</h5></div></div></div><p>The <tt class="filename">color</tt> subdirectory contains
      marking files specific to the architecture of the system.  See
      <a href="#Marking-chapter" title="Chapter 4. Marking">Chapter 4, <i>Marking</i></a>
      for details concerning these files.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2481022"></a>gen</h5></div></div></div><p>The <tt class="filename">gen</tt> subdirectory contains code
      generated for the system.  <tt class="filename">source</tt>,
      <tt class="filename">include</tt> and <tt class="filename">object</tt>
      directories lie below <tt class="filename">gen</tt> containing
      ANSI C source modules, generated include files and compiled
      object code respectively.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2481055"></a>schema</h5></div></div></div><p>The <tt class="filename">schema</tt> subdirectory contains
      generated data base files and a directory to age the
      regeneration of portions of the system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2481072"></a>skel</h5></div></div></div><p>The <tt class="filename">skel</tt> subdirectory contains
      source code frameworks or skeletons that can be modified.
      The interface to the timer subsystem is generated into
      this directory.  Outbound bridge frameworks are placed
      here also.  Code in the <tt class="filename">skel</tt>
      directory is not compiled and included in the build.
      Files must be moved under the <tt class="filename">user</tt>
      directory structure to be visible by the build process.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2481106"></a>user</h5></div></div></div><p>The <tt class="filename">user</tt> subdirectory is visible
      to the model compiler build process but is largely left
      to the user to populate with source files.  It makes sense
      to copy the generated framework skeletons into this
      area.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2481129"></a>Domain Nodes</h4></div></div></div><p>The domain directories are named after their Nucleus BridgePoint Model Builder
    repository names.  These directories contain the generated
    application code.  The following
    subdirectories are found therein:</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2481146"></a>color</h5></div></div></div><p>The <tt class="filename">color</tt> subdirectory contains
      marking files specific to the application of the specific
      domain.  See
      <a href="#Marking-chapter" title="Chapter 4. Marking">Chapter 4, <i>Marking</i></a>
      for details concerning these files.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2481167"></a>gen</h5></div></div></div><p>As with the system, the <tt class="filename">gen</tt>
      subdirectory contains code generated for the specific
      application domain.  <tt class="filename">source</tt>,
      <tt class="filename">include</tt> and <tt class="filename">object</tt>
      directories lie below <tt class="filename">gen</tt> containing
      ANSI C source modules, generated include files and compiled
      object code respectively.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2481201"></a>schema</h5></div></div></div><p>The <tt class="filename">schema</tt> subdirectory contains
      generated data base files and a directory to age the
      regeneration of portions of the system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2481218"></a>skel</h5></div></div></div><p>As with the system, the <tt class="filename">skel</tt>
      subdirectory contains source code frameworks or skeletons
      that can be modified.  These source files are specific to the
      domain and contain operation frameworks.  Copy to the
      <tt class="filename">user</tt> area and modify/augment as
      required.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2481242"></a>user</h5></div></div></div><p>The <tt class="filename">user</tt> subdirectory is for
      user supplied code.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2481258"></a>Other Subdirectories</h4></div></div></div><p>At the node root level a few more subdirectories
    can be found.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2481270"></a>bin</h5></div></div></div><p>The <tt class="filename">bin</tt> will contain the compiled,
      linked, located executable.  A file containing a list of
      the object modules included in the link will also be
      generated during build and placed here.  A script which
      contains the link/locate command for the C compiler being
      used is also found here.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2481292"></a>reports</h5></div></div></div><p>The <tt class="filename">reports</tt> subdirectory contains
      multiple generated report files.  These report files provide
      metrics and statistics concerning the translation.  Error
      messages and warning will be found here.  Carefully read
      the contents of these reports, especially when having
      difficulty with you system generation.</p></div></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2481317"></a>rox_build:  Command Line Build Automation</h2></div></div></div><p>A build execution utility called rox_build is available
  to enable translation from model backup and SQL files.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2481331"></a>Utility</h3></div></div></div><p>A command line build utility called <span><b class="command">rox_build</b></span>
    allows for custom automation of the build process and for
    building from exported model files.  <span><b class="command">rox_build</b></span>
    operates on Nucleus BridgePoint models exported to <tt class="filename">*.xtuml/*.sql/*.bak</tt>
    files as well as <tt class="filename">*.xtuml</tt> files from Nucleus BridgePoint
    version 7 and beyond.  <span><b class="command">rox_build</b></span> will create
    a build directory,
    copy in the supplied marking files and translate a model supplied
    in a file.  This frees the build process from the Nucleus BridgePoint model
    repository.</p><p>One expected use for <span><b class="command">rox_build</b></span> would be
    automation of batch oriented build operations.  Once marking
    and configuration of a particular build have been established
    interactively, <span><b class="command">rox_build</b></span> can be used to
    repeat the build in a single step.</p><p><span><b class="command">rox_build</b></span> can also be used in
    conjunction with third-party version control systems (such as
    CVS, CleareCASE).  <span><b class="command">rox_build</b></span> could also be
    used when building models extracted from multiple repositories.
    A build server could use this utility to perform automatic
    translation of newly checked in materials.  <span><b class="command">rox_build
    </b></span> also serves in test suite automation.</p><p>Note that <tt class="filename">.mark</tt> is superceding
    <tt class="filename">.clr</tt> for the extension of marking files
    (formerly coloring files).  <tt class="filename">.clr</tt> is maintained
    for backward compatibility.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2481435"></a>Usage</h3></div></div></div><p>To get the latest syntax for <span><b class="command">rox_build</b></span>
    run:  <span><b class="command">rox_build -h</b></span>.  Command line help will
    be supplied.
    </p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef"><b class="fsfunc">rox_build</b>(</code></td><td> </td><td><var class="pdparam">-h</var>, </td></tr><tr><td> </td><td> </td><td><var class="pdparam">-d directory</var>, </td></tr><tr><td> </td><td> </td><td><var class="pdparam">-O output directory</var>, </td></tr><tr><td> </td><td> </td><td><var class="pdparam">-e</var>, </td></tr><tr><td> </td><td> </td><td><var class="pdparam">-m xtUML model file</var>, </td></tr><tr><td> </td><td> </td><td><var class="pdparam">-o xtUML_domain</var>, </td></tr><tr><td> </td><td> </td><td><var class="pdparam">-s SQL_file</var>, </td></tr><tr><td> </td><td> </td><td><var class="pdparam">-r EE</var>, </td></tr><tr><td> </td><td> </td><td><var class="pdparam">-f file</var><code>)</code>;</td></tr></table></div><p>
    Where the command line parameters are:
    </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">-h</span></td><td><p>
      Usage help will be printed.</p></td></tr><tr><td><span class="term">-e</span></td><td><p>
      This is used to indicate that <span><b class="command">rox_build</b></span>
      was called from EDGE/Eclipse/Tiger.</p></td></tr><tr><td><span class="term">directory</span></td><td><p>
      Directory into which the generated code will be built.
      This directory will be created.  Be sure it does not 
      already exist.</p></td></tr><tr><td><span class="term">output directory</span></td><td><p>
      Directory/folder into which the generated source files
      will be copied.  Only the .c and .h files will be copied
      to this folder.  This folder must already
      exist.</p></td></tr><tr><td><span class="term">xtUML model file</span></td><td><p>This is
      the xtUML model as from Nucleus BridgePoint Model Builder version 7 or later.
      </p></td></tr><tr><td><span class="term">xtUML_domain</span></td><td><p>This
      is the domain name as known inside Nucleus BridgePoint Model Builder (not the registered
      domain name).</p></td></tr><tr><td><span class="term">SQL_file</span></td><td><p>This is
      the xtUML model as dumped from Nucleus BridgePoint Model Builder using the Export
      capability.</p></td></tr><tr><td><span class="term">EE</span></td><td><p>EE is a
      ``realized'' external entity that the current xtUML_domain uses.
      </p></td></tr><tr><td><span class="term">file</span></td><td><p>All of the
      marking files (<tt class="filename">bridge.clr, system.mark, etc.</tt>)
      are each listed with the <span><b class="command">-f</b></span> flag.
      <tt class="filename">.c</tt> and <tt class="filename">.h</tt> files
      are listed in the same way.  When running multiple domains,
      domain marking files must be prepended with their domain
      name and underscore, for example <tt class="filename">-f microwave_domain.mark
      </tt> or <tt class="filename">-f odms_class.mark</tt>.
      </p></td></tr></tbody></table></div><p>

    </p><div class="example"><a id="id2481635"></a><p class="title"><b>Example 5.1. Simple rox_build Example</b></p><pre class="programlisting">
rox_build -d d -o dogs -m dogs.xtuml -r ARCH -f dogs_domain.mark -f registry.mark 
      </pre></div><p>
    </p><div class="example"><a id="id2481649"></a><p class="title"><b>Example 5.2. Two Domain rox_build Example</b></p><pre class="programlisting">
rox_build -d ae1 -o as2 -s as2.sql -r CARPIO -r SPPIO -r UI -f as2_domain.mark
-f as2_event.mark -f bridge.mark -f registry.mark -f datatype.mark -o exp
-s exp.sql -f exp_domain.mark -f sys_user_co.c -f sys_user_co.h -f link_sys
      </pre></div><p>
    </p><p>Note that (-f) files should be listed immediately following their
    own domain when making a multi-domain build.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2481675"></a>Sample/Example Timer (TIM)</h2></div></div></div><p>xtUML provides a model of time.  Time can be read, time can
  be measured and delayed events can be generated.  Nucleus BridgePoint Model Builder provides a
  "standard" interface to time through an external entity (EE) called
  Time (TIM).  A set of bridge operations on the TIM external entity
  have become somewhat standardized.  Among these are
  <span><b class="command">TIM::timer_start</b></span>,
  <span><b class="command">TIM::get_date</b></span>,
  <span><b class="command">TIM::timer_cancel</b></span>. etc.</p><p>Since measuring time is often dependendent upon the target
  platform, MC-3020 provides no formal support for time in the
  generated code.  However, a sample Time EE is generated and can
  easily be modified by the user.  This sample provides an excellent
  head start when building a timer on a particular target.</p><p>In order to use these timers:
  </p><div class="itemizedlist"><ul type="disc"><li><p> <tt class="filename">TIM_bridge.c</tt> and
    <tt class="filename">TIM_bridge.h</tt> are automatically generated
    into the <tt class="filename">system/skel</tt> folder.
    </p></li><li><p>The generated <tt class="filename">TIM_bridge.c</tt>
    will have a <tt class="function">pause</tt> and
    <tt class="function">resume</tt> that will be used to suspend time)
    when generated with Model Debugging enabled.</p></li><li><p>To use the sample TIM, references to the TIM
    routines in <tt class="filename">sys_user_co.c</tt> must be
    uncommented.  These calls initialize and periodically "tick" the
    timer subsystem.  These references are are found in
    <tt class="function">UserInitializationCalloutf</tt> and
    <tt class="function">UserBackgroundProcessingCalloutf</tt>.</p></li><li><p>Modifications made to define timer routines must
    be made in <tt class="filename">sys_user_co.h</tt>
    (<tt class="function">UserInitializationCallout</tt>
    <tt class="function">UserBackgroundProcessingCallout</tt>). The
    initial macros defining these routines as empty must be commented
    out or deleted.</p></li><li><p><tt class="function">TIM_init</tt> must be invoked at
    start-up (this is normally done by uncommenting the line found in
    <tt class="function">UserInitializationCalloutf</tt>.</p></li><li><p><tt class="function">TIM_tick</tt> must be invoked
    periodically and as often as practical (normally done by
    uncommenting the line found in
    <tt class="function">UserBackgroundProcessingCalloutf</tt>.</p></li></ul></div><p>
  </p><p>Many users have enhanced the given sample to be asynchronous.
  Instead of calling <tt class="function">TIM_tick</tt> periodically from
  the background loop, it can be asynchronously invoked with a
  signal.  It can also be spawned into its own thread.  The TIM as
  generated for the Nucleus PLUS environment does this.  The user may
  augument and enhance this sample as desired.</p></div></div><div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="Enum-chapter"></a>Chapter 6. Enumerated Types</h2></div></div></div><div class="highlights"><a id="Enum-chapter-high"></a><p>Nucleus BridgePoint Model Builder allows users
to define types derived from its set of core data types.
Support for the Nucleus BridgePoint Model Builder interface for defining enumerated types
is fully supported.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2482239"></a>Overview of Enumeration Support</h2></div></div></div><div class="highlights"><p>Enumerations provide the ability to represent
  discrete component sets in xtUML.  MC-3020 supports the translation
  of these enumerated types into ANSI C.</p></div><p>Many systems require the ability to define a data type that can
  take on a finite number of discrete values.  The current release of
  Nucleus BridgePoint provides support for enumeration data types.  MC-3020
  4.0 provides support for the translation of enumerations
  and provides several extensions that are described here.  Previous
  versions of Nucleus BridgePoint did not support enumerations natively within the
  tool.  The previous method for specifying enumerations by using
  strings is no longer documented but is still supported by MC-3020 for
  backward compatibility.  Each enumeration specified in the xtUML models
  is translated into ANSI C defined constants.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2482833"></a>Specifying Enumerations</h2></div></div></div><div class="highlights"><p>To specify an enumeration using the facilities
  provided by MC-3020, use the steps described
  in the following sections.</p></div><p>Use Nucleus BridgePoint Model Builder create your enumeration data types.  Enumerations are
  created using the Data Type Data Editor under the Domain Package
  Diagram (DPD) canvas.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2482881"></a>Specifying a Discrete Value for Enumerators</h3></div></div></div><p>MC-3020 supports the specification of a discrete value for
    each of the enumerators for an enumeration. There are two ways in
    which the value can be assigned: 1) through the use of a keyword in
    the description of the enumerator, and 2) through marking. In the
    absence of any value specified by the user, MC-3020 assigns a
    default.  MC-3020 gives priority to those values specified via
    marking.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2482889"></a>Value Keyword</h4></div></div></div><p>MC-3020 recognizes a special keyword that the analyst
      places in the description of the enumerator.  The keyword can be
      any one of the following three: Value, value, or VALUE.  Note that
      the keyword is case sensitive so using vaLuE will not work
      properly. The keyword should be used on a single line as in:
      </p><div class="blockquote"><blockquote class="blockquote"><pre class="programlisting">
Value:  3
      </pre></blockquote></div><p>
      with a colon immediately after the keyword followed by the desired
      value.</p><p>Other examples of usage include:
      </p><div class="blockquote"><blockquote class="blockquote"><pre class="programlisting">
value:  0x4
Value:  23
VALUE:  0xFFF
      </pre></blockquote></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2482942"></a>Marking</h4></div></div></div><p>The marking function
      <tt class="function">TagEnumeratorDiscreteValue</tt> can also be used
      to specify the value for an enumerator.  The marking function
      overrides any value specified in the analysis model.  See <a href="#SpecifyingEnumValues-section" title="Specifying Values&#10;      for Enumerators">the section called “Specifying Values
      for Enumerators”</a> for complete
      details on this marking option.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2482968"></a>Avoiding Multiple Implementations for Enumerations</h3></div></div></div><p>Each domain that uses an enumeration must define the
    enumeration.  In other words, Nucleus BridgePoint Model Builder currently provides no
    means to place a set of enumerations in a common area where all
    domains being modeled can access them.</p><p>In order to avoid duplicate definitions for identical sets of
    enumerations in the generated code, MC-3020 provides the ability to
    inform the translation process of a single domain that ``owns'' the
    enumeration. Doing so produces a declaration for the enumeration in
    a single translated domain which other domains include.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2482989"></a>Keyword</h4></div></div></div><p>Establishing the owning domain for an enumeration is done
      via a keyword placed in the description of the enumeration in the
      non-owning domain.  The keyword can be one of three names:  Owner,
      owner, or OWNER.  Note that the keyword is case sensitive so using
      oWNer will not work properly.  The keyword should be used on a
      single line as in:
      </p><div class="blockquote"><blockquote class="blockquote"><pre class="programlisting">Owner:  MO</pre></blockquote></div><p>
      Other examples of usage include:
      </p><div class="blockquote"><blockquote class="blockquote"><pre class="programlisting">
owner:  B
Owner:  CP
OWNER:  MO
      </pre></blockquote></div><p>
      The registered domain name for the owning domain follows the
      keyword and a colon.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2483034"></a>Accessing an Enumeration from a Non-Modeled Domain</h3></div></div></div><p>Enumerations that are defined within a modeled domain can
    also be used by manually written code.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2483046"></a>Enumeration Header File Name</h4></div></div></div><p>The name of the header file containing the enumerations for
      a domain is of the following form:  <tt class="filename">(registered domain
      name)_enums.h</tt>.  For example, the name of the header
      file containing the enumerations defined in the microwave domain
      with registered name M is <tt class="filename">M_enums.h</tt>.  The file
      is placed in the system-level include directory
      <tt class="filename">system/gen/include</tt>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2483077"></a>Access to an Enumeration</h4></div></div></div><p>In MC-3020, enumerations translate into simple
      <span><b class="command">#define</b></span>s.  Each member (enumerator) of
      the enumeration is defined to a value.  Each enumerator
      member uses the name of the enumeration as the part of it
      own name to prevent name collisions between enumerators in
      different enumerations.</p><p>To use the enumerators in a hand-coded C module,
      simply include the <tt class="filename">(domain)_enums.h</tt>
      and use the desired constants defined within.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2483114"></a>Using an Enumeration</h2></div></div></div><div class="highlights"><p>An enumeration can be used by the domain in which
  it is defined as well as by other domains.  The following sections
  describe the use of an enumeration.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2483129"></a>Legal Uses of an Enumeration</h3></div></div></div><p>The user-defined type that represents an enumeration is a
    legal type for all of the following data items:
    </p><div class="itemizedlist"><ul type="disc"><li><p>object attribute</p></li><li><p>event supplemental data item</p></li><li><p>bridge argument</p></li><li><p>bridge return value</p></li><li><p>operation argument</p></li><li><p>operation return value</p></li><li><p>domain function argument</p></li><li><p>domain function return value</p></li></ul></div><p>
    </p><p>Enumerators
    can also be used in the following operations:
    </p><div class="itemizedlist"><ul type="disc"><li><p>comparison for equality and
      inequality</p></li><li><p>assignment to local variable</p></li></ul></div><p>
    </p></div></div></div><div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="Callout-chapter"></a>Chapter 7. Interface Call-outs</h2></div></div></div><div class="highlights"><a id="Callout-chapter-high"></a><p>Interface call-outs
allow the user to capture execution control of the generated system
running on a target.</p></div><p>Especially in
the deeply embedded software development world, it may be
necessary to tightly interface the xtUML system to the 
surrounding/containing system.  MC-3020 provides callout routines
that enable the user to easily interface code generated by the
model compiler with other system code.  These callout
routines are empty when generated by the model compiler.  It is
up to the user to define additional functionality (if necessary)
to be performed at these callout points.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2482521"></a>Using Callouts</h2></div></div></div><div class="highlights"><p>MC-3020 tries to provide callout functions at
  as many key points of control as possible.  It is the goal of the
  model compiler to make it easy for the user to interface to the
  generated code.</p></div><p>The user callout file <tt class="filename">sys_user_co.c</tt>
  will initially be generated into the user source directory
  in the system area (<tt class="filename">system/user/source/</tt>).
  After being generated once, it will not be overwritten by the
  model compiler.  Thus, it is safe to edit the file.  The user
  should add invocations from this file into appropriate system
  specific functionality.</p><p>MC-3020 generates hooks into the generated at key points
  where these callouts are needed.  In versions of MC-3020
  before 3.0, these hooks represented real C instructions
  even if the callouts where not being used actively.  In
  version 3.0 (and following), the <tt class="filename">sys_user_co.h</tt>
  defines the hooks as macros.  Until they are activated,
  they take no time or space inline with the generated code.
  They are effectively invisible.
  The comments in the sys_user_co files explain how to
  activate and modify the callouts.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2483682"></a>Callout Routines Provided</h3></div></div></div><p>Edit <tt class="filename">sys_user_co.h </tt> to activate
    particular callout functions.  Edit
    <tt class="filename">sys_user_co.c</tt> to add code to the defined
    callout routines.  It is important that both files be edited to
    enable the callout capability.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2483704"></a>User Initialization</h4></div></div></div><p>This function is invoked at the immediate beginning of
      application initialization.  It is the very first function to be
      executed at system startup.  User supplied implementation of
      this function should be restricted to things like memory
      initialization, early hardware duties, etc.</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserInitializationCallout</b>(</code><code>void)</code>;</p></div><div class="example"><a id="id2483737"></a><p class="title"><b>Example 7.1. Bring-up Initialization</b></p><pre class="programlisting">
        void UserInitializationCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2483755"></a>User Pre-xtUML Initialization</h4></div></div></div><p>This function is invoked immediately prior to executing
      any xtUML application initialization function.</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserPreOoaInitializationCallout</b>(</code><code>void)</code>;</p></div><div class="example"><a id="id2483782"></a><p class="title"><b>Example 7.2. Pre-xtUML Initialization</b></p><pre class="programlisting">
        void UserPreOoaInitializationCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2483798"></a>User Post-xtUML Initialization</h4></div></div></div><p>This function is invoked immediately after executing any/all
      xtUML application initialization function(s).  When this
      callout function returns, the system dispatcher will allow the
      xtUML state models to start consuming events.</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserPostOoaInitializationCallout</b>(</code><code>void)</code>;</p></div><div class="example"><a id="id2483825"></a><p class="title"><b>Example 7.3. Post-xtUML Initialization</b></p><pre class="programlisting">
        void UserPostOoaInitializationCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2483842"></a>User Background Processing</h4></div></div></div><p>This function is invoked once during each loop execution
      of the system dispatcher.  (This may be an excellent place to
      hang an invocation to a timer (TIM) tick routine.)</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserBackgroundProcessingCallout</b>(</code><code>void)</code>;</p></div><div class="example"><a id="id2483869"></a><p class="title"><b>Example 7.4. Background Processing</b></p><pre class="programlisting">
        void UserBackgroundProcessingCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2483885"></a>User Pre-Shutdown Processing</h4></div></div></div><p>This function is invoked at termination of the system
      dispatcher, but prior to performing any xtUML application
      shutdown sequencing.</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserPreShutdownCallout</b>(</code><code>void)</code>;</p></div><div class="example"><a id="id2483912"></a><p class="title"><b>Example 7.5. Pre-Shutdown</b></p><pre class="programlisting">
        void UserPreShutdownCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2483929"></a>User Post-Shutdown Processing</h4></div></div></div><p>This function is invoked immediately before application
      exit.</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserPostShutdownCallout</b>(</code><code>void)</code>;</p></div><div class="example"><a id="id2483954"></a><p class="title"><b>Example 7.6. Post-Shutdown Callout</b></p><pre class="programlisting">
        void UserPostShutdownCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2483972"></a>User Event ``Can't Happen'' Processing</h4></div></div></div><p>This function is invoked any time that an event is
      received that results in a ``can't happen'' transition.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef"><b class="fsfunc">UserEventCantHappenCallout</b>(</code></td><td>const Escher_StateNumber_t  </td><td><var class="pdparam">current_state</var>, </td></tr><tr><td> </td><td>const Escher_StateNumber_t  </td><td><var class="pdparam">next_state</var>, </td></tr><tr><td> </td><td>const Escher_EventNumber_t  </td><td><var class="pdparam">event_number</var><code>)</code>;</td></tr></table></div><p>Where the input parameters are:</p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">current_state</span></td><td><p>is
        the number of the state before the
        transition.</p></td></tr><tr><td><span class="term">next_state</span></td><td><p>is
        the number of the calculated next
        state.</p></td></tr><tr><td><span class="term">event_number</span></td><td><p>is
        the number of the event that is stimulating this
        transition.</p></td></tr></tbody></table></div><div class="example"><a id="id2484052"></a><p class="title"><b>Example 7.7. Event Can't Happen</b></p><pre class="programlisting">
        void UserEventCantHappenCallout( const Escher_StateNumber_t current_state,
                                         const Escher_StateNumber_t next_state,
                                         const Escher_EventNumber_t event_number
        )
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2484075"></a>User Event with No Instance Processing</h4></div></div></div><p>This function is invoked any time that an event is
      received and there is no target instance to receive it.  This
      often means that the instance was deleted while the event was
      in flight.  Usually this indicates a modeling error.  The
      default behavior without supplying a body to this function is
      simply to consume the event and go on.</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserEventNoInstanceCallout</b>(</code>const Escher_EventNumber_t <var class="pdparam">event_number</var><code>)</code>;</p></div><p>Where the input parameters are:</p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">current_state</span></td><td><p>is
        the number of the state when event is
        dispatched.</p></td></tr><tr><td><span class="term">next_state</span></td><td><p>is
        the number of the calculated next
        state.</p></td></tr><tr><td><span class="term">event_number</span></td><td><p>is
        the number of the event that is landing on the missing
        object instance.</p></td></tr></tbody></table></div><div class="example"><a id="id2484149"></a><p class="title"><b>Example 7.8. Event with No Instance</b></p><pre class="programlisting">
        void UserEventNoInstanceCallout( const Escher_EventNumber_t event_number
        )
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2484164"></a>User Event Free List Empty</h4></div></div></div><p>This function is invoked when an attempt is made to
      allocate an event, but there are no more left.</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserEventFreeListEmptyCallout</b>(</code><code>void)</code>;</p></div><div class="example"><a id="id2484190"></a><p class="title"><b>Example 7.9. Event Free List Empty Handler</b></p><pre class="programlisting">
        void UserEventFreeListEmptyCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2484208"></a>User Empty Handle Detection</h4></div></div></div><p>When marked active, this function is invoked
      when an attempt is made to
      use an instance reference variable (handle) that is null
      (empty).</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserEmptyHandleDetectedCallout</b>(</code>c_t * <var class="pdparam">object_keyletters</var>, c_t * <var class="pdparam">string</var><code>)</code>;</p></div><div class="example"><a id="id2484243"></a><p class="title"><b>Example 7.10. User Empty Handle Detection</b></p><pre class="programlisting">
        void UserEmptyHandleDetectedCallout( const char * object_keyletters,
                                             const char * s )
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2484260"></a>User Object Pool Empty Handling</h4></div></div></div><p>This function is called from instance creation
      methods when an attempt is made to create an instance
      of an object and no allocation units are available.</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserObjectPoolEmptyCallout</b>(</code>c_t * <var class="pdparam">domain</var>, c_t * <var class="pdparam">object_name</var><code>)</code>;</p></div><div class="example"><a id="id2484295"></a><p class="title"><b>Example 7.11. Object Pool Empty</b></p><pre class="programlisting">
        void UserObjectPoolEmptyCallout( const char * domain,
                                         const char * object_name )
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2484312"></a>Empty Node List Handling</h4></div></div></div><p>MC-3020 uses a collection of set ``containoids'' to
      link data items together in lists.  These utility list
      nodes are used collecting extents, events and relationships.
      In the situation that an attempt is made to allocate a node,
      but none are available, this function will be called.</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserNodeListEmptyCallout</b>(</code><code>void)</code>;</p></div><div class="example"><a id="id2484344"></a><p class="title"><b>Example 7.12. Node List Empty</b></p><pre class="programlisting">
        void UserNodeListEmptyCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2484362"></a>Overflow of Interleaved Bridge Invocations</h4></div></div></div><p>MC-3020 uses an array as a queue to manage invocations
      of interleaved bridges (bridge operations marked safe for
      interrupt invocation).  UserInterleavedBridgeOverflowCallout
      is invoked when an attempt is made to post too many
      interleaved bridges.  The depth of this list is defined by
      SYS_MAX_INTERLEAVED_BRIDGES (unless changed in the rule file).</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserInterleavedBridgeOverflowCallout</b>(</code><code>void)</code>;</p></div><div class="example"><a id="id2484395"></a><p class="title"><b>Example 7.13. Overflow of Interleaved Bridge</b></p><pre class="programlisting">
        void UserInterleavedBridgeOverflowCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2484411"></a>Empty Event Queue Callouts</h4></div></div></div><p>If the user wishes to gain control of processing when
      either of the two event queues are empty (no events to
      be processed at the current time), two callouts are provided.
      <tt class="function">UserSelfEventQueueEmptyCallout</tt> and
      <tt class="function">UserNonSelfEventQueueEmptyCallout</tt> are
      invoked (assuming they are enabled) each time the corresponding
      event queue is interrogated and found to be empty.</p><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserSelfEventQueueEmptyCallout</b>(</code><code>void)</code>;</p></div><div class="funcsynopsis"><p><code class="funcdef"><b class="fsfunc">UserNonSelfEventQueueEmptyCallout</b>(</code><code>void)</code>;</p></div><div class="example"><a id="id2484462"></a><p class="title"><b>Example 7.14. Event Queue Empty Notification</b></p><pre class="programlisting">
        void UserSelfEventQueueEmptyCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        void UserNonSelfEventQueueEmptyCalloutf()
        {
          /* Insert implementation specific code here.  */
        }
        </pre></div></div></div></div></div><div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="Initialization-chapter"></a>Chapter 8. Initialization and
Preexisting Instances</h2></div></div></div><div class="highlights"><a id="Initialization-chapter-high"></a><p>This chapter
explains how to initialize and start the system.  Initialization
must deal with bringing up the architecture system code as well
as initialization for preexisting instances.
</p></div><p>
MC-3020 supports dynamic and constant initialization of preexisting
instances.  Dynamic initialization is simple and flexible while
constant initialization is a powerful optimization allowing for
reduction in code space and increase in initializationspeed.
</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Initialization-chapter-Overview-section"></a>Initialization Overview</h2></div></div></div><div class="highlights"><p>It is possible to define preexisting instance
  populations dynamically with action language and constantly with data
  definitions.  Instance populations can be static, dynamic and/or
  read-only.</p></div><p>MC-3020 supports two methods of initialization, dynamic and
  constant.  Both methods provide a means of creating and
  setting up the preexisting instances required for a system at
  bring-up time.  Both methods provide a way of creating the preexisting
  instances, relating them one to another and setting the values of
  their attributes.  Each method of initialization has advantages and
  disadvantages.  Each method is useful in design situations that
  leverage the advantages.  The following sections will describe each
  method of performing system initialization.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2485426"></a>Preexisting Instances</h3></div></div></div><p>When specifying a system with xtUML models, the analyst is
    allowed to assume that there are preexisting instances of classes
    within the models.  MC-3020 provides two methods for specifying
    these preexisting instances, the values of their attributes, and
    the relationships between them.  This dynamic creation, linking
    and initialization of preexisting instances is described in
    <a href="#Initialization-chapter-DynamicInit-section" title="Dynamic Initialization">the section called “Dynamic Initialization”</a>.
    Defining preexisting instances with data is described in
    <a href="#Initialization-chapter-ConstantInit-section" title="Constant Initialization">the section called “Constant Initialization”</a>.</p><p>The preexisting instances of xtUML classes can be
    created during system bring-up from the specifications
    provided by the analysts in
    the form of initialization functions.  These preexisting instances
    are created before normal execution of the system is allowed to
    proceed.  Thus, the xtUML models can assume that all the preexisting
    instances exist before any events are accepted.</p><p>Note that MC-3020 automatically creates a single instance
    for every assigner in the system.  The analyst does not need to
    model or mark anything to make this happen.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2485479"></a>Terminology</h3></div></div></div><p>In order to avoid confusion resulting from the following
    paragraphs as well as in future documentation,
    the following definitions will be used with respect to
    instance populations and preexisting instances:
    </p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>static instance population:</em></span>
    an instance population to which additions or
    deletions are never made during system execution (after
    initialization)</p></li><li><p><span class="emphasis"><em>implicitly defined static instance
    population:</em></span> the use of a static instance
    population for a class due to the absence of associated
    create/delete statements in model action
    language</p></li><li><p><span class="emphasis"><em>explicitly defined static instance
    population:</em></span> the use of a static instance
    population (no creates/deletes) for a class based on a
    <tt class="function">TagStaticInstancePopulation</tt> mark for that
    class</p></li><li><p><span class="emphasis"><em>dynamic instance
    population:</em></span> an instance population to which
    additions and deletions may be made during system execution
    (after initialization)</p></li><li><p><span class="emphasis"><em>implicitly defined dynamic instance
    population:</em></span> the use of a dynamic instance
    population for a class based on the presence of associated
    create/delete statements in model action
    language</p></li><li><p><span class="emphasis"><em>preexisting instances defined using
    executable statements:</em></span> preexisting instances that are
    established at run time through the use of an executable
    initialization routine</p></li><li><p><span class="emphasis"><em>dynamic initialization:</em></span>
    preexisting instances that are established at run time through the
    use of an executable initialization routine (same
    as<span class="emphasis"><em>preexisting instances defined using executable
    statements</em></span>)</p></li><li><p><span class="emphasis"><em>preexisting instances defined in
    data:</em></span> preexisting instances which are established
    through the use of constant data (in the form of ANSI C
    initializers)</p></li><li><p><span class="emphasis"><em>constant initialization:</em></span>
    preexisting instances which are established
    through the use of constant data (in the form of ANSI C
    initializers) (same as <span class="emphasis"><em>preexisting instances defined in
    data</em></span>)</p></li><li><p><span class="emphasis"><em>read-only instance population:</em></span>
    instance population that cannot be written</p></li></ul></div><p>
    </p><p>It is easy to see that many combinations of static/dynamic,
    read-only, implicit/explicit and preexisting can occur in normal
    system analysis.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2485700"></a>Constructs Supported</h3></div></div></div><p>In MC-3020 3.1 and beyond, preexisting instances can be
    defined in data for any normal modeling construct supported by
    MC-3020  For example, dynamic or constant initialization can be
    defined for:
    </p><div class="itemizedlist"><ul type="disc"><li><p>simple 1-1 associations</p></li><li><p>simple 1-* associations</p></li><li><p>associatives (1-1, 1-*, *-*)</p></li><li><p>subtypes</p></li><li><p>supertypes</p></li><li><p>sub/supertypes</p></li><li><p>simple reflexive associations</p></li><li><p>simple 1-* reflexives</p></li><li><p>reflexive associatives</p></li><li><p>asymmetric reflexive associatives</p></li></ul></div><p>
    </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Initialization-chapter-DynamicInit-section"></a>Dynamic Initialization</h2></div></div></div><div class="highlights"><p>The simples and easiest way to initialize
  preexisting instance is using dynamic
  initialization.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2485785"></a>Dynamic Init Process</h3></div></div></div><p>Dynamic initialization uses sequences of action language
    statements to create, relate and set attributes of preexisting
    instances.  This form of initialization has been supported by MC-3020
    since the first release (1.0).</p><p>Action language statements in initialization functions (or
    previously in init objects) are executed once when a system first
    starts.  The action language statements perform
    <span><b class="command">create</b></span> statements to
    create the preexisting instances.  <span><b class="command">Relate</b></span>
    statements execute to establish associations between these newly
    created instances.  Action languages statements are executed which
    write the attribute values of the preexisting instances.</p><p>When all of the action language statements are complete for all
    init functions (tagged with
    <tt class="function">TagInitializationFunction</tt>), then all preexisting
    instances are fully established and initialization is complete.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2485835"></a>Pros and Cons of Dynamic Init</h3></div></div></div><p>Advantages to dynamic initialization include:
    </p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>flexibility</td><td>It is easy to add, delete and/or change dynamic initialization.
    This is done by simply adding, deleting and/or changing the action
    language in the init functions.</td></tr><tr><td>simplicity</td><td>Dynamic initialization is simple and easy to understand.</td></tr></tbody></table></div><p>
    </p><p>Disadvantages to dynamic initialization include:
    </p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>memory space</td><td>The space in the system instruction store used by the
    initialization action language statements
    can be substantial.  This space is not availabe for use after the
    init process is complete.</td></tr><tr><td>speed</td><td>It takes time (execution time) during bring-up to create,
    relate and populate the preexisting instances.</td></tr></tbody></table></div><p>
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2486199"></a>Initialization Functions</h3></div></div></div><p>The basic building block for specifying preexisting instances
    is the initialization function.  This approach provides the user with
    the ability to use the same set of preexisting instances for
    simulation with the Nucleus BridgePoint Model Verifier as are used during the actual execution
    of the system on the target platform.</p><p>Initialization functions
    contain the action language that describes the set of
    preexisting instances for the subsystem or domain.
    Initialization functions are normal functions and can
    be invoked during normal system execution as well as at
    start-up.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2486232"></a>Rules for Creating Initialization Functions</h3></div></div></div><p>The rules for constructing initialization functions are
    enumerated below.
    </p><div class="orderedlist"><ol type="1"><li><p>Each subsystem can have one to many
      initialization functions.  The functions will be invoked
      in alphabetical order during bring-up.
      Initialization functions are identified by
      marking in the <tt class="filename">object.clr</tt> marking
      file.</p></li><li><p>Initialization functions are tagged with
      the marking function <tt class="function">TagInitializationFunction</tt>.
      </p></li><li><p>Initialization functions can take no
      arguments.  Return values will be ignored.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2486281"></a>Example of Dynamic Initialization</h3></div></div></div><p><a href="#as2class-figure" title="Figure 8.1. Autosampler Class Diagram">Figure 8.1, “Autosampler Class Diagram”</a> shows the xtUML class diagram
    for the autosampler example model.  Note that the autosampler
    example model can be found in the <tt class="filename">examples</tt>
    directory of your MC-3020 installation.
    <a href="#as2init-figure" title="Figure 8.2. Autosampler Init Function">Figure 8.2, “Autosampler Init Function”</a>
    shows the action language statements contained in the initialization
    function for the autosampler domain.  The function is marked as
    an init function with the statement
    </p><pre class="programlisting">TagInitializationFunction( "setup" )</pre><p>
    in the <tt class="filename">object.clr</tt> marking file.
    This init function executes
    creates, relates and attribute writes to establish all preexisting
    instances.  The function runs once and only once at system
    start.

    </p><div class="figure"><a id="as2class-figure"></a><p class="title"><b>Figure 8.1. Autosampler Class Diagram</b></p><div class="mediaobject"><img src="as2class.png" alt="Autosampler Class Diagram" /></div></div><p>

    </p><div class="figure"><a id="as2init-figure"></a><p class="title"><b>Figure 8.2. Autosampler Init Function</b></p><div class="informalexample"><p>
    </p><pre class="programlisting">
create object instance car of CAR;
car.carousel_ID=10;
car.current_position=10;
create object instance row of ROW;
relate row to car across R1;
row.radius=10;
row.current_sampling_position=0;
row.maximum_sampling_positions=20;
row.sampling_time=3000000;  // 3 seconds
row.needs_probe=false;
create object instance probe of SP;
probe.probe_ID=1;
probe.radial_position=20;
probe.theta_offset=40;
probe.current_position="up";
probe.available = true;
    </pre><p>
    </p></div></div><p>

    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2486384"></a>Multi-Domain Dynamic Initialization</h3></div></div></div><p>In systems with more than one domain, dynamic init is only
    slightly more complex.  Initialization functions are written for
    each domain.  These multiple init functions establish the
    preexisting instances (PEIs) for the multiple domains.  The init
    functions are each marked with
    <tt class="function">TagInitializationFunction</tt> in each domain's
    corresponding <tt class="filename">object.clr</tt> marking
    file.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2486415"></a>Multi-Domain Init Sequencing</h3></div></div></div><p>In some systems it is important that certain domains be
    initialized before other domains.  Or, there may be requirements on
    the ordering of the initialization between domains.  In these cases,
    a function in only one domain is tagged as an init function (using
    <tt class="function">TagInitializationFunction</tt>).  This function
    then invokes functions in the other domains, thus imposing the
    desired order on the initialization sequence.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2486443"></a>Initialization in Simulation</h3></div></div></div><p>To simulate the xtUML models with the same set of preexisting
    instances that are used on the target system, the analyst must
    invoke the initialization functions.  Nucleus BridgePoint Model Verifier provides a facility
    to do this very easily.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Initialization-chapter-ConstantInit-section"></a>Constant Initialization</h2></div></div></div><div class="highlights"><p>As an alternative to dynamic initialization, constant
  initialization allows for optimizing the space and speed required for
  system init.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2486482"></a>Constant Initialization Process</h3></div></div></div><p>Constant initialization involves providing the preexisting
    instances (PEIs) in the form of constant data.  Instead of executing
    action language statements to create, relate and set attributes of
    preexisting instances, these PEIs are supplied as constant data
    already created, related and set.</p><p>ANSI C provides a construct called a static initializer.
    This construct allows constant data to be assigned to a variable
    at initialization time.  MC-3020 provides a method for establishing
    the preexisting instances data in the form of ANSI C static
    intializers.  The instance collections in the generated system are
    initialized with this data.</p><p>To obtain the PEI data necessary to provide constant
    initialization, a process must execute action language statements
    just as in dynamic initialization and then take a "snap shot" of the
    initialized data elements (PEIs) for use later.  The PEI data from
    the snap shot is captured in an XML format.  This PEI data is then
    used in placed of dynamic initialization action language.</p><p>Dynamic initialization as described in
    <a href="#Initialization-chapter-DynamicInit-section" title="Dynamic Initialization">the section called “Dynamic Initialization”</a>
    defines preexisting
    class instances and the associations between them by producing
    executable code from analysis model initialization function action
    language.  The code produced in this fashion is executed once at
    system startup in order to establish any necessary preexisting
    instances.  This mechanism may be unsatisfactory due to:
    </p><div class="itemizedlist"><ul type="disc"><li><p>the execution time associated with the
      definition of preexisting instances and</p></li><li><p>the use of memory to hold code that is
      executed once (and only once) at system startup</p></li></ul></div><p>
    </p><p>MC-3020 addresses this issue in such a way as to provide
    an alternative approach for the establishing preexisting
    instances.
    </p><div class="orderedlist"><ol type="1"><li><p>The model, with initialization functions
      is translated by MC-3020 for the development host
      with Model Debugger (MD) support, and the resulting
      MC-instrumented code is compiled and linked into an
      executable.</p></li><li><p>The instrumented executable built in step 1
      is brought up on the development host under MD control, and an
      initialization function is executed. As the PEIs are
      created, the MD is notified, and it updates its view of the
      instance population.</p></li><li><p>After all the PEIs have been created (might
      require the execution of several initialization 
      functions), the user instructs the MD to dump the instance
      population, and the MD does so, storing the instance population
      as an XML file.</p></li><li><p>The XML file created in step 3 is supplied to
      MC-3020 for a second translation, this time with tags indicating
      data defined preexisting instances.  MC-3020 uses the XML file
      containing the PEI definitions to create initialized array
      definitions representing the PEIs.  These arrays are prepopulated
      by ANSI C static initializers.  It also translates the model for
      the target, ignoring the initialization that the user has now
      marked (with <tt class="function">TagFunctionTranslationOff</tt>) so
      that code is not generated for them.  The user then compiles and
      links the result into an executable that contains PEIs defined in
      data.  The resulting executable does not contain executable code
      corresponding to the excluded initialization
      functions.</p></li></ol></div><p>
    </p><p>This approach, illustrated in
    <a href="#peidfd-figure" title="Figure 8.3. &#10;    Model Debugger Architecture">Figure 8.3, “
    Model Debugger Architecture”</a>
    directly addresses both of the issues of speed and space
    identified in the introduction to this section.</p><div class="figure-float"><div class="figure"><a id="peidfd-figure"></a><p class="title"><b>Figure 8.3. 
    Model Debugger Architecture</b></p><div class="mediaobject"><img src="peidfd.png" alt="Model Debugger Architecture" /></div></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2486681"></a>XML Representation of Instance Data</h3></div></div></div><p>An XML data format has been defined which can represent
    instances, their associations and their attribute values.  A file
    containing this XML data is generated.  Then the constants of this
    file are supplied when generating the target system.  Constant PEI
    initializers are created which establish PEIs just as if an init
    object had been executed.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2486703"></a>Pros and Cons of Constant Init</h3></div></div></div><p>Advantages to constant initialization include:
    </p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>memory space</td><td>Constant init saves instruction store space
    in the target system by generating more compact initialization in
    the form of preexisting instance array static initializers.</td></tr><tr><td>speed</td><td>Initialization is quicker with constant preexisting instances
    defined in data.</td></tr></tbody></table></div><p>
    </p><p>Disadvantages to constant initialization include:
    </p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>complexity</td><td>The process for creating the initialization data for
    constant initialization is much more complex than for dynamic
    initialization.  The model debugger is involved, and there are
    more steps.</td></tr></tbody></table></div><p>
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2486814"></a>How To Use Constant Initialization (PEIs in Data)</h3></div></div></div><p>To use the preexisting instance support, an XML file
    containing the preexisting instance definitions needs to be
    supplied to the translation process.  It is supplied into the
    <tt class="filename">(domain)/schema/sql</tt>
    directory.  It is named
    <tt class="filename">(domain)_pei.xml</tt>.</p><p>Note that when the model is changed in any substantial way,
    the PEI data needs to be regenerated.</p><p>To create this file you must run the debugger, execute 
    initialization code and save the results as XML.  Two marks
    facilitate this.
    <tt class="function">TagInitializationFunction</tt>
    marks function(s) to be executed during bring-up.  This
    effectively replaces initialization objects.  (Initialization
    objects are still supported, but discouraged.) Functions tagged
    to run at initialization bring-up can also be called during run
    time processing.  Functions tagged for initialization are run in
    alphabetical order.</p><p><tt class="function">TagFunctionTranslationOff</tt>
    disables the translation of functions.  This is convenient for
    enabling/disabling test cases.  It is especially nice for PEI
    support.  An init function can be tagged for running with model
    debugger.  It can then be tagged off for the production compile
    using Preexisting Instances defined in data.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2486880"></a>General Process</h4></div></div></div><p>The general process is as follows:
      </p><div class="orderedlist"><ol type="1"><li><p>Compile a model with debugging
        enabled.</p></li><li><p>Run with Nucleus BridgePoint Model Debugger and run initialization
        code.</p></li><li><p>Save the initialized data into XML file.
        </p></li><li><p>Recompile model incorporating the saved
        initialization XML from the debug session.</p></li></ol></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2486922"></a>Step-by-Step Specifics</h4></div></div></div><p>The specific details are as follows:
      </p><div class="orderedlist"><ol type="1"><li><p>Compile a model with debugging
        enabled.
        </p><div class="orderedlist"><ol type="a"><li><p><tt class="function">TagModelDebuggingOn</tt>
          to enable debugging and the transmission of XML state
          information to the Model Debugger.  This marking function is
          invoked from the <tt class="filename">system.clr</tt> marking
          file.</p></li><li><p>Run the model compiler.</p></li></ol></div></li><li><p>Run with Model Debugger and run the initialization
        code.
        </p><div class="orderedlist"><ol type="a"><li><p>Launch Nucleus BridgePoint Model Debugger.</p></li><li><p>Run the compiled model
          (<tt class="filename">bin/rox.exe</tt>).</p></li><li><p>Invoke the domain function containing the
          initialization action language statements.  Do this by right
          clicking on the function in the Model Debugger system browser.  Select
          <tt class="function">invoke function</tt>.</p></li><li><p>State or action step through the
          initialization code until all desired preexisting instances
          are created, related and initialized.</p></li></ol></div></li><li><p>Save XML from model
        debugger.
        </p><div class="orderedlist"><ol type="a"><li><p>Under the file menu of Model Debugger, save as... and
          save XML file into the 
          <tt class="filename">(domain)/schema/sql</tt> directory as
          <tt class="filename">(domain)_pei.xml</tt>.</p></li><li><p>Exit Model Debugger.</p></li></ol></div></li><li><p>Recompile model with preexisting instances
        defined in data.
        </p><div class="orderedlist"><ol type="a"><li><p>Disable model debugging by not executing
          the <tt class="function">TagModelDebuggingOn</tt>
          in the <tt class="filename">system.clr</tt> marking file.
          </p></li><li><p>Do not
          <tt class="function">TagInitializationFunction</tt>
          in the <tt class="filename">domain.clr</tt> marking file
          for the initialization function that does
          creates, relates and inits.  (You may want to run a
          function at bring-up for other purposes such as generating
          events.)</p></li><li><p><tt class="function">TagFunctionTranslationOff</tt>
          in the <tt class="filename">domain.clr</tt> marking file
          to prevent the initialization function from being
          translated into code that takes up time and
          space.</p></li><li><p>Mark on the constant initialization by invoking
          <tt class="function">TagPEIsDefinedInData</tt> in the
          <tt class="filename">object.clr</tt> marking file.</p></li><li><p><span><b class="command">make clean_all_src</b></span>
          to erase generated source in domains.</p></li><li><p><span><b class="command">make clean_sys_src</b></span>
          to erase generated source in the system node.</p></li><li><p>If you copied files into
          <tt class="filename">system/user/source</tt>
          or <tt class="filename">system/user/include</tt>, you may
          need to change these not to
          include debug header files.</p></li><li><p><span><b class="command">make all</b></span> to rebuild
          the code with the preexisting instances defined in data
          and without debugging code.</p></li></ol></div></li></ol></div><p>
      </p><p>If you are working with multiple domains, the process
      is the same with steps 2 and 3 repeated for each domain.  Run the
      initialization of each domain separately.  (Exit and restart Model Debugger
      for each domain.) Save separate XML
      files, one for each domain in its respective
      <tt class="filename">(domain)/schema/sql</tt> directory.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2487169"></a>Example of Constant Initialization</h3></div></div></div><p>In the following example the pei test case (found in 
    the <tt class="filename">pei</tt> directory in the MC-3020 
    installation) will be translated to use constant initialization.
    <a href="#peiclass-figure" title="Figure 8.4. PEI Test Case Class Diagram">Figure 8.4, “PEI Test Case Class Diagram”</a> shows the class diagram
    for this model.
    
    </p><div class="figure"><a id="peiclass-figure"></a><p class="title"><b>Figure 8.4. PEI Test Case Class Diagram</b></p><div class="mediaobject"><img src="peiclass.png" alt="PEI Test Case Class Diagram" /></div></div><p>

    The model is designed to test various forms of associations between
    classes.  Import the backup file, <tt class="filename">pei.sql</tt>, into
    your installation of Nucleus BridgePoint Model Builder as a model called pei.  Check it in and
    create a configuration view.  (Ensure all of the actions are
    parsed.)</p><p>Build a system node for the build
    (<span><b class="command">rox_init_node [dir]</b></span>) and make the domain node
    (<span><b class="command">make dom_node domain=pei</b></span>).
    Register the pei domain and the "LOG" realized domain by
    supplying the appropriate Register commands in
    <tt class="filename">registry.clr</tt>.
    Enable model debugging in <tt class="filename">system.clr</tt>.
    Wire the bridge between pei and LOG in
    <tt class="filename">bridge.clr</tt>, make the bridge skeleton files
    (<span><b class="command">make bridge_skel domain=pei ee=LOG</b></span>) and
    copy the generated <tt class="filename">.c</tt> and <tt class="filename">.h</tt>
    files from the <tt class="filename">system/skel</tt> directory
    into the <tt class="filename">user/source</tt> and
    <tt class="filename">user/include</tt> directories.
    Build the executable as normal (<span><b class="command">make all</b></span>).
    </p><p>Fire up Nucleus BridgePoint Model Debugger and run the generated executable
    (<tt class="filename">bin/rox.exe</tt>).  Invoke the domain function
    "setup" from the system browser as shown in
    <a href="#peibrowse-figure" title="Figure 8.5. MD System Browser for PEI&#10;    Test Case">Figure 8.5, “MD System Browser for PEI
    Test Case”</a>.
    (In <a href="#peiinitlisting-appendix" title="Appendix E. PEI Test Case Setup">Appendix E, <i>PEI Test Case Setup</i></a> the entire listing
    of the PEI test case is shown in detail.)

    </p><div class="figure"><a id="peibrowse-figure"></a><p class="title"><b>Figure 8.5. MD System Browser for PEI
    Test Case</b></p><div class="mediaobject"><img src="peibrowse.png" alt="MD System Browser for PEI Test Case" /></div></div><p>

    After invoking and stepping through the <tt class="function">setup</tt>
    function, the Nucleus BridgePoint Model Debugger should show results as in
    <a href="#mdpei-figure" title="Figure 8.6. MD PEI Test Case Initializing">Figure 8.6, “MD PEI Test Case Initializing”</a>.

    </p><div class="figure"><a id="mdpei-figure"></a><p class="title"><b>Figure 8.6. MD PEI Test Case Initializing</b></p><div class="mediaobject"><img src="mdpei.png" alt="MD PEI Test Case Initializing" /></div></div><p>

    Save the session XML into <tt class="filename">schema/sql/pei_pei.xml</tt>
    under the system node created for this build.
    </p><p>Turn off model debugging in <tt class="filename">system.clr</tt>
    and block translation of the domain function "setup" (with
    </p><pre class="programlisting">.invoke TagFunctionTranslationOff( "setup" )</pre><p>
    in <tt class="filename">domain.clr</tt>).
    Clean out the source code generated with model debugging
    capability (<span><b class="command">make clean_all_src</b></span> and
    <span><b class="command">make clean_sys_src</b></span>).
    Activate the constant initialization capability by marking on
    the PEIs with
    </p><pre class="programlisting">.invoke TagPEIsDefinedInData( "*", "*" )</pre><p>
    in the <tt class="filename">object.clr</tt> marking file.  By using
    the asterisks all available XML PEI data will be used.
    </p><p>Rebuild the application with the new marking
    (<span><b class="command">make all</b></span>).  The generated executable will
    be smaller and will start up faster because of the constant
    initialization.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2487434"></a>Multi-Domain Constant Initialization</h3></div></div></div><p>To perform multiple domain constant initialization the user
    must collect XML data for each domain separately.  A separate
    Nucleus BridgePoint Model Debugger session is started for each domain.  The XML data is
    saved for each domain under the correct <tt class="filename">schema/sql</tt>
    directory.  Below is a summary example using the autosampler
    example model (found in <tt class="filename">examples/ae</tt> of
    the MC-3020 installation).</p><p>In <a href="#expclass-figure" title="Figure 8.7. Experiment Class Diagram">Figure 8.7, “Experiment Class Diagram”</a> the experiment (exp) xtUML
    class diagram is shown.  The autosampler class diagram is shown
    in <a href="#as2class-figure" title="Figure 8.1. Autosampler Class Diagram">Figure 8.1, “Autosampler Class Diagram”</a>.

    </p><div class="figure"><a id="expclass-figure"></a><p class="title"><b>Figure 8.7. Experiment Class Diagram</b></p><div class="mediaobject"><img src="expclass.png" alt="Experiment Class Diagram" /></div></div><p>

    After the model is built with model debugging enabled, Nucleus BridgePoint Model Debugger and
    the generated executable (<tt class="filename">bin/rox.exe</tt> are
    started and the System Browser shows as in
    <a href="#expbrowse-figure" title="Figure 8.8. MD System Browser for exp and as2">Figure 8.8, “MD System Browser for exp and as2”</a>.

    </p><div class="figure"><a id="expbrowse-figure"></a><p class="title"><b>Figure 8.8. MD System Browser for exp and as2</b></p><div class="mediaobject"><img src="expbrowse.png" alt="MD System Browser for exp and as2" /></div></div><p>

    The initialization code is run for each domain separately.  First,
    the autosampler domain function "init" is run as shown in
    <a href="#as2mdinit-figure" title="Figure 8.9. MD Initializing Autosampler">Figure 8.9, “MD Initializing Autosampler”</a>.  The XML data is saved
    into <tt class="filename">as2/schema/sql/as2_pei.xml</tt> under the
    system node created for the build.

    </p><div class="figure"><a id="as2mdinit-figure"></a><p class="title"><b>Figure 8.9. MD Initializing Autosampler</b></p><div class="mediaobject"><img src="as2mdinit.png" alt="MD Initializing Autosampler" /></div></div><p>

    The Nucleus BridgePoint Model Debugger is exited and restarted (also restarting the generated
    application).
    The exp domain function "init" is run as shown in
    <a href="#expmdinit-figure" title="Figure 8.10. MD Initializing Experiment">Figure 8.10, “MD Initializing Experiment”</a>.  The XML data is saved
    into <tt class="filename">exp/schema/sql/exp_pei.xml</tt> under the
    system node created for the build.

    </p><div class="figure"><a id="expmdinit-figure"></a><p class="title"><b>Figure 8.10. MD Initializing Experiment</b></p><div class="mediaobject"><img src="expmdinit.png" alt="MD Initializing Experiment" /></div></div><p>

    Turn off model debugging in <tt class="filename">system.clr</tt> and
    block translation of the domain functions "init" in both domains
    (with
    </p><pre class="programlisting">.invoke TagFunctionTranslationOff( "init" )</pre><p>
    in the <tt class="filename">domain.clr</tt> marking
    files).  Clean out the source code generated with model debugging
    capability (<span><b class="command">make clean_all_src</b></span> and <span><b class="command">make
    clean_sys_src</b></span>).  Activate the constant initialization
    capability by marking on the PEIs with
    </p><pre class="programlisting">.invoke TagPEIsDefinedInData( "*", "*" )</pre><p>
    in the <tt class="filename">object.clr</tt> marking files of both as2 and exp
    domains.  Rebuild the application with the new marking
    (<span><b class="command">make all</b></span>).
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2487669"></a>Gain from PEIs Defined in Data</h3></div></div></div><p>Following is an example of the gain (reduced code size)
    achieved by defining preexisting instances in data.  Below are size
    measurements of a test case.  The first case shows the output of
    the <span><b class="command">size</b></span> command for a normal init-object-style
    generation (gcc/Cygwin).  The second shows using
    <tt class="function">PEIsDefinedInData</tt>.</p><p>To interpret the table:
    </p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>text:</em></span> code
    space</p></li><li><p><span class="emphasis"><em>data:</em></span> constants</p></li><li><p><span class="emphasis"><em>bss:</em></span> global and static
    variables</p></li></ul></div><p>

    </p><div class="table"><a id="id2487723"></a><p class="title"><b>Table 8.1. PEI Comparison</b></p><table summary="PEI Comparison" width="100%" border="1"><colgroup><col /><col /><col /><col /><col /><col /></colgroup><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th><th>hex</th><th>filename</th></tr></thead><tbody><tr><td>27136</td><td>2560</td><td>11104</td><td>40800</td><td>9f60</td><td>s2t/bin/rox.exe</td></tr><tr><td>20992</td><td>10240</td><td>3744</td><td>34976</td><td>88a0</td><td>s2s/bin/rox.exe</td></tr></tbody></table></div><p>
    </p><p>This is a conservative test case.  There are no state machines
    in the model.  However there is procedural action language to
    access all of the instances either created or defined in data.
    The test case creates a total of 84 instances of 23 different
    objects with 39 links.</p><p>This simple test demonstrates a 15% reduction in code
    space and a significant speed-up in terms of initialization.
    Models with many preexisting instances will see very large
    reductions in code size.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2487885"></a>Create/Delete/Link/Unlink Optimization</h4></div></div></div><p>Create, delete and link accessors are not generated unless
      actually needed.  Early versions of MC-3020 were able
      to optimize out some delete and link accessors.  Create
      accessors were generated unconditionally.</p><p>With the advent of preexisting instances defined in
      data it is possible for a system to have instances that were
      not created by action language in the system but were defined
      in data.  As such, some classes may not need create accessors.</p><p>During first pass translation, MC-3020 identifies
      all creates, deletes, links and unlinks that are needed.
      All accessors are assumed to be not needed until action
      language is identified that uses the accessor.  Only those
      accessors actually used in action language are generated.</p><p>With a static instance population composed totally
      of preexisting instances defined in data, it is possible to
      have a large number of instances that are rich with attributes
      and related with many other instances that have no create,
      delete, link or unlink accessors!</p></div></div></div></div><div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="Collections-chapter"></a>Chapter 9. MC-3020 Collections</h2></div></div></div><div class="highlights"><a id="Collections-chapter-high"></a><p>Lists are used by MC-3020
to keep track of collections of instances in the system.  Collections
of instances appear in several contexts including pools of instances
of classes, sets of instances participating in an association and
sets of instances resulting from SELECT MANY statements.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2489537"></a>MC-3020 Collections</h2></div></div></div><div class="highlights"><p>MC-3020 manages collections of instances using
  various collection mechanisms which are selectable through marking.
  As of version 3, MC-3020 provides two flavors of collection
  container, singly linked lists (slists) and doubly linked lists
  (dlists).  Each container strategy has advantages and disadvantages
  with regard to code size and speed.  In general, dlists are faster
  but take more storage.  In the following sections details of
  these constructs are outlined.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2489547"></a>Containers</h3></div></div></div><p>Collections of class instances (objects) must be supported by
    any model compiler.  Processing performs operations on these
    sets of data.  Instances can be collected and organized in
    several ways.  At minimum, a model compiler must be able to
    support:
    </p><div class="itemizedlist"><ul type="disc"><li><p>selection from the existing instances of any
      specified class</p></li><li><p>selection from instances of any associated
      class</p></li><li><p>the analysis variable type <span class="type">inst_ref_set</span>
      </p></li></ul></div><p>
    We refer to the first case as instance extents.  The second are
    referred to as association extents.  The third are
    transient set variables (often called selection extents).</p><p>As of version 3, MC-3020 maintains collections in linked
    lists.  Linked lists are flexible and relatively light
    weight (small, simple code).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2490184"></a>Sets</h3></div></div></div><p>Operations on sets include <tt class="function">Insert</tt>,
    <tt class="function">Remove</tt>, <tt class="function">Clear</tt>,
    <tt class="function">Copy</tt>, <tt class="function">Cardinality</tt>,
    <tt class="function">IsEmpty</tt>, <tt class="function">Equality</tt>,
    <tt class="function">Contains</tt> and <tt class="function">Iterate</tt>.
    Some variations on these methods may also be included for various
    optimizations.</p><p>SELECT MANY makes a copy of an instance extent or
    association extent into a transient set variable.  Cursors are
    used to iterate through sets of instances.</p><p>SELECT ANY returns the first element in the instance extent
    or association extent.</p><p>A set generates a different type of variable than does
    an element in a set.  This allows for sets to have attributes
    such as a head (and perhaps a tail and cardinality).  Set
    elements have attributes such as a link to the next element
    and a pointer to the substance of the data they contain.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2490259"></a>Set Symmetry</h3></div></div></div><p>Consistency between the three flavors of collections
    makes the model compiler simpler.  Simpler usually means
    smaller code, but there are some exceptions to this general
    rule.  Up through version 2.2 of MC-3020, instance extents,
    association extents and transient sets were treated almost
    identically.  In versions above 2.2, instance extents get
    special treatment so that the model compiler can optimize
    for size and speed based upon characteristics true only of
    instance extents.</p><p>Instance extent sets are treated special in
    that their containers are never returned to the free pool and
    remain permanently attached to the instance data.  Since the
    instances basically move between active (animate) and inactive
    (inanimate) lists, there is no need to detach the container as
    in association extents and transient set variables.  Although
    this breaks the symmetry, it enables the generation of
    smaller and faster code.</p><p>MC-3020 applies these specializations as
    marking options to enhance the set operation performance
    of the model compiler generated code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2490300"></a>Singly Linked Lists</h3></div></div></div><p>Singly linked lists are simple and small.  For most of the
    set operations, singly linked lists are fast because of their
    simplicity.  The exception to this is the delete operation.  A
    delete operation on a singly linked set requires the address of
    the container of the data element being deleted.  Delete also
    requires the  address of the container preceding the deleted data
    and the address of the container following the deleted item.  As
    input we have none of these three addresses but only the address
    of the data (object) being deleted.</p><p>In MC-3020 marked with slist containers, this meant that a
    search for the data element is required.  This search begins at
    the head of the list and proceeds down the list until the data
    element is found.  Variables track the current node and previous
    nodes as the list is traversed.  Once the data element is found,
    these node variables contain 2 of the 3 three needed container
    addresses.  A simple dereference of current-&gt;next yields the final
    container address.  The singly linked list delete links the
    previous container to the next container thus unlinking the
    current node.</p><p>As collections get large, this linear search involved
    in set item deletion gets burdensome.</p><div class="figure-float"><div class="figure"><a id="slist-figure"></a><p class="title"><b>Figure 9.1. 
    Singly Linked Lists of Instances</b></p><div class="mediaobject"><img src="slist.png" alt="Singly Linked Lists of Instances" /></div></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2490365"></a>Doubly Linked Lists</h3></div></div></div><p>Adding a more capable container node structure 
    alleviates the delete instance problem.  With a prev pointer
    together with the next pointer, it is an easy matter to
    learn the address of the previous and following containers
    given the address of the container containing the data to be
    deleted.  Note however, that we are not given the address
    of the container but the address of the data itself.  Thus,
    unless a clever mechanism exists for deriving (divining)
    the container from the data handle, we are relegated to
    linear searches once again.</p><div class="figure-float"><div class="figure"><a id="dlist-figure"></a><p class="title"><b>Figure 9.2. 
    Doubly Linked Lists of Instances</b></p><div class="mediaobject"><img src="dlist.png" alt="Doubly Linked Lists of Instances" /></div></div></div><p>If data allocation of instances and containers is
    performed in a special way, there does exist a mechanism for
    deriving the address of the container from the address of the
    data.</p><p>In MC-3020 versions beyond 2.2, a doubly linked list
    container is available.  Instances and containers are
    allocated in memory in a way that relates the instances to
    their containers mathematically.  One container pool is
    allocated for each pool of class instances.  These are
    parallel arrays.  Remember that the container stays
    attached to the instance for the duration of system run
    time, since instances from the extents are simply moved from
    inactive to active and back for create and delete
    respectively.</p><p>During initialization, containers are linked to instance
    data in parallel.  Container 0 is the container for instance
    index 0 of any particular class.  Container 1 is the container
    for the instance at index two in the class pool array for this
    class.  In other words, the array indexes for the containers
    are the same as the array indexes of the instances for which
    they serve.</p><div class="figure-float"><div class="figure"><a id="parallel-figure"></a><p class="title"><b>Figure 9.3. 
    Parallel Container/Object Arrays</b></p><div class="mediaobject"><img src="parallel.png" alt="Parallel Container/Object Arrays" /></div></div></div><p>Thus, if we know the index of an instance data element,
    we know the index of the instance extent container pointing to
    it.  We can derive the index of any pointer to an array element
    through pointer arithmetic.</p><p>
    </p><pre class="programlisting">
    index = pointer_to_array_element - address_of( array_element[0] )
    </pre><p>
    </p><p>We now have all the information needed to derive the
    address of an instance container, its previous container and
    next container all in constant time.  The delete operation on
    an instance no longer involves a linear search of the
    extent.</p><p>Note that this "magic" only applies to sets managing
    instance extents.  Deletions from association extents,
    UNRELATES, are not helped and still involve a search of the
    set.  UNRELATES from very large association extents (hundreds
    or thousands) can suffer from linear search overhead.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2490525"></a>Performance Considerations</h3></div></div></div><p>A comparison of the two collection mechanisms in light of
    deleting instances shows the power of the constant time address
    derivation.  Once instance extents grow larger than one
    hundred, the doubly linked collection mechanism with address
    derivation begins to show benefit.  At extent sizes of ten
    thousand (10,000), the singly linked collection mechanism
    becomes two orders of magnitude slower than the doubly linked
    counterpart.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2490546"></a>Merged Containers</h3></div></div></div><p>Another clever way to relate the instance containers to the
    instances themselves is to allocate them
    <span class="emphasis"><em>inside</em></span> of the instances themselves.  Under
    such a scheme, the base instance class would have the container
    class as its first element.  This would amount to overloading the
    class with container members as data elements, namely next,
    prev, and object.  Such a scheme renders trivial the mathematics
    of deriving the address of the instance from the address of the
    container.  They are exactly the same.  The address of the
    container is the address of the instance (and vice versa).</p><div class="figure-float"><div class="figure"><a id="merged-figure"></a><p class="title"><b>Figure 9.4. 
    Containers Merged Into Instance Data</b></p><div class="mediaobject"><img src="merged.png" alt="Containers Merged Into Instance Data" /></div></div></div><p>Such a scheme suffers a weakness in light of preexisting
    instance (PEI) support.  The merged containers scheme adds two or
    three pointer size data elements to every class instance.  To
    populate the instances with data, it would be necessary to
    populate the container pointers with the instances.  Even if zero,
    this would mean 4 to 12 bytes of additional constant initializer
    data per instance in the system.</p><p>In light of this weakness, MC-3020 has opted for the
    parallel array approach to mathematically relating the
    containers to the instances.  Even though MC-3020 does not
    (currently) use merged containers, there remains a great deal
    of merit in the approach.</p></div></div></div><div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="Debugger-chapter"></a>Chapter 10. Model Debugger</h2></div></div></div><div class="highlights"><a id="Debugger-chapter-high"></a><p>As of version 3.1
MC-3020 supports debugging with the Nucleus BridgePoint Model Debugger.  This adds powerful
capabilities to the software developer.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2490430"></a>MC-3020 with Model Debugger</h2></div></div></div><div class="highlights"><p>Using XML data exchange and embedded tooling
  code generated by the model compiler, MC-3020 delivers real-time
  debugging of translated models.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2489942"></a>Model Debugger Architecture</h3></div></div></div><p>The Model Debugger architecture, as originally conceived,
    is composed of four primary components: the Model Debugger
    itself, a host monitor, a target monitor, and an executable image
    generated from the model to be debugged.  The host and target
    monitors, are separate entities with well-defined
    functionality.  From a conceptual perspective, these four
    components can be allocated to completely separate processes or
    processors if it should prove beneficial to do so.  Conversely,
    they can all be placed on the same processor.  The Model Debugger
    will always runs as a separate process.  These four components
    and the form of interaction between them are depicted in 
    <a href="#debugarch1-figure" title="Figure 10.1. &#10;    Model Debugger Architecture">Figure 10.1, “
    Model Debugger Architecture”</a>.</p><div class="figure-float"><div class="figure"><a id="debugarch1-figure"></a><p class="title"><b>Figure 10.1. 
    Model Debugger Architecture</b></p><div class="mediaobject"><img src="debugarch1.png" alt="Model Debugger Architecture" /></div></div></div><p>In version 3.1, MC-3020 implements this architecture
    as shown in
    <a href="#debugarch2-figure" title="Figure 10.2. &#10;    Current Debugger/Compiler Interface">Figure 10.2, “
    Current Debugger/Compiler Interface”</a>.  This provides full code
    generation and debug capability, but restricted to the host
    development platform or to a TCP/IP socket-capable target.</p><div class="figure-float"><div class="figure"><a id="debugarch2-figure"></a><p class="title"><b>Figure 10.2. 
    Current Debugger/Compiler Interface</b></p><div class="mediaobject"><img src="debugarch2.png" alt="Current Debugger/Compiler Interface" /></div></div></div><p>Note that the host and target monitors are not
    only combined, but are incorporated into the executable image.
    As such, these three components exist as a single process that
    communicates with the Model Debugger process via XML messages
    across TCP/IP sockets.  Both the Executable Image and Model Debugger
    processes run on the same host machine.</p><p>An interest in debugging models in a target environment
    using a Model Debugger compatible version of 
    MC-3020 currently exists.  In order to field such a
    capability in the first release, it was required to 
    bundle host and target monitor capabilities with the executable
    image and communicate with the Model Debugger using XML Messages
    as shown in 
    <a href="#debugarch2-figure" title="Figure 10.2. &#10;    Current Debugger/Compiler Interface">Figure 10.2, “
    Current Debugger/Compiler Interface”</a>.  This assumes that the
    target is a socket-capable platform with sufficient RAM to
    run the tooled executable.</p><div class="figure-float"><div class="figure"><a id="debugarch3-figure"></a><p class="title"><b>Figure 10.3. 
    Near Term Debugger/Compiler Interface</b></p><div class="mediaobject"><img src="debugarch3.png" alt="Near Term Debugger/Compiler Interface" /></div></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2491339"></a>Running MC-3020 with Model Debugger</h3></div></div></div><p>To run with Nucleus BridgePoint Model Debugger it is necessary to mark the system
    to generate the target monitor.  This is accomplished with the
    marking function <tt class="function">TagModelDebugginOn</tt>.
    See <a href="#DebuggerMark-section" title="Marking On Model Debugger">the section called “Marking On Model Debugger”</a> for more details on
    this marking.</p><p>Before running the application with the debugger, an
    XML extraction of the model must be prepared.  Use the command
    <span><b class="command">make gen_all_xml</b></span> to create XML extractions
    for each domain in the system.  If you do not prepare this
    XML file, Nucleus BridgePoint Model Debugger will detect an error and may exit with a fatal
    error.</p><p>When running with the target monitor enabled, additional
    code is translated into the generated code.  There is code to
    communicate with the Model Debugger through a socket interface.  There is
    an XML parser which parses the XML messages received from the
    debugger.  In line with normal action processing are calls to
    debug processing which keeps the Model Debugger synchronized with the
    state of the generated target code.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2491386"></a>International Character Sets</h4></div></div></div><p>With the addition of debugging with Nucleus BridgePoint Model Debugger another
      touch point between plain ASCII character sets and Unicode
      character sets is exposed.  During a debug-enabled translation,
      the model compiler accesses and embeds various constructs from
      within the Nucleus BridgePoint xtUML model into the generated code.  The constructs
      include the names and values of xtUML modeling elements.  Many of
      these elements can be encoded in international character sets
      (for example Shift_JIS).</p></div></div></div></div><div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="Persistence-chapter"></a>Chapter 11. Persistence</h2></div></div></div><div class="highlights"><a id="Persistence-chapter-high"></a><p>This chapter describes
persistence services for MC-3020.  The persistence support in MC-3020
allows instances of classes marked as persistent to survive across
power cycles.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2491344"></a>Introduction</h2></div></div></div><p>Persistence capability in a model compiler refers to the ability
  of the model compiler to allow dynamic data to persist across the
  boundary of a power cycle.  The value of a persistent attribute
  written before power disconnect or power loss will be restored when
  the power returns.</p><p>MC-3020 does not support persistence of dynamic data
  in versions 3.3 and earlier.  This section outlines requirements
  and operation of persistence support.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2490932"></a>High-Level Requirements</h2></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2490938"></a>Non-volatile Storage Technology</h3></div></div></div><p>There are a great number of options for non-volatile storage
    (NVS) technologies in the embedded control world.  Applications
    exist which use more than one non-volatile storage technology
    within the same system.  It is required that modularity exist
    at the
    interface between general persistence services and the driver
    level code storing and retrieving data from non-volatile storage.
    A bridge is defined to allow MC-3020 users to build or
    replace this driver layer.</p><p>An option must be supplied to allow for the persisting of the
    current state of a persistent class instance or to use the default
    initial state.  By default MC-3020 must restore the current state
    of instances.  But the user must have a way of causing the current
    state to be the default current state that would normally be
    established for non-persistent class instances.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2490956"></a>Granularity</h3></div></div></div><p>Different applications need to persist different amounts of
    data.  The ability to persist at the class and domain levels
    allows for both large and small amounts of persistent data.
    MC-3020 supports persistence at class, subsystem and domain levels.
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2490987"></a>Balance</h3></div></div></div><p>Some approaches to persistence can add tremendous complexity
    to the model compiler.  Overly simplistic approaches to
    persistence support can pollute the application analysis.  MC-3020
    strikes a balance that makes sense for the embedded
    applications to which MC-3020 is best suited.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2491008"></a>Operational Overview</h2></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2491016"></a>General Scenario</h3></div></div></div><p>Persistence services for MC-3020 are light weight and
    flexible in terms of non-volatile storage technology.  The
    persistence services are broken between two domains, PERSIST
    and NVS.</p><p>The PERSIST domain performs the commit and restore
    operations which commit instances to non-volatile storage
    and restore instances from non-volatile storage respectively.
    The PERSIST domain keeps track of which instances have been
    persisted, which links have been persisted and manages keeping
    the links synchronized with the instances during the power-up
    system initialization.</p><p>The NVS domain supplies a rudimentary but functionally
    complete persistent data storage and retrieval interface.
    The interface has characteristics of both a database
    and of a file system.  The interface is rich enough to
    provide flexibility in the application of different non-volatile
    storage technologies.</p><p>MC-3020 persistence does not specify or depend upon
    a specific persistent storage technology.  Therefore, only
    a standard interface (bridge) is defined.  The user may deploy
    whatever available technology desired behind the bridge to
    the NVS domain.  A sample implementation is supplied (in a file
    called <tt class="filename">sys_nvs.c/h</tt>) for use
    as the developer desires.</p><p>The domain chart below shows the bridge operations made
    visible to the application.  <tt class="function">commit</tt>
    is the primary function used by the application.</p><p>The architecture domain (MC-3020) automatically
    performs the <tt class="function">insert</tt>s, <tt class="function">update</tt>s
    and <tt class="function">delete</tt>s to shuffle instance data between the
    RAM based collections of the application and the non-volatile
    persistent storage.  Additionally, MC-3020 automatically performs the
    <tt class="function">restore</tt> operation at power-up time.</p><p>Other domain interfaces are exposed and may be
    used at the discretion of the analyst.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2491944"></a>Manual and Automatic Commit</h3></div></div></div><p>A <span class="emphasis"><em>manual commit</em></span> occurs when the user
    forces a commit of instance and link data to non-volatile store
    by synchronously invoking a PERSIST domain function (e.g.
    <tt class="function">PERSIST::commit()</tt>).  An <span class="emphasis"><em>automatic
    commit</em></span> occurs when a commit is initiated by the software
    architecture "behind the scenes" based on pre-defined policy.</p><p>MC-3020 supports manual commit operations and performs
    automatic commits when necessary.  Such automatic commits occur
    when instance and link delete operations are required.</p><p>When persistence and tasking are both enabled in the generated
    system, MC-3020 performs all commits automatically.  It is not advised
    to manually commit in a multi-tasking system.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2491992"></a>Assumptions</h2></div></div></div><p>The implementation and deployment of the Non-Volatile Store (NVS)
  domain is the responsibility of the user.  MC-3020 supplies one or more
  sample implementations of this domain to serve as design examples and
  source code "head starts".  Mentor Graphics Corporation will develop and collect
  additional samples over time and make these available to users.
  However, with the variety of non-volatile storage technologies available
  and broadly differing platform requirements this deployment is left to
  the user for the purposes of flexibility.</p><p>Class instances and relationship instances (links) are stored in
  non-volatile storage.  Their types are kept distinct from the rest of
  their instance data.  In other words, the NVS domain distinguishes
  between instance data and link data.</p><p>Instances and links will be created and deleted in a rigorous 
  fashion in the action language.  Instances will be deleted only after
  all links have been "unrelated".</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2492030"></a>Limitations</h2></div></div></div><p>Only class instances and links between
  persistent classes are stored/retrieved from NVS.  (Events and
  timers are not persisted.)</p><p>MC-3020 instance storage space is reused.  The memory used to
  store the data for a class instance is moved from and to a "pool of
  elements" when creating and deleting class instances.  Thus, after an
  instance is deleted, another instance may be created that uses the
  same physical storage.  This poses a challenge when maintain two
  copies of this data (one in RAM and one in NVS).</p><p>If associations are not unlinked prior to the associated 
  instances being deleted, links will be "orphaned" in non-volatile store.
  As such, this implementation of persistence requires the action
  language to carefully unlink before deleting.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2492066"></a>Persistence Marking Options</h2></div></div></div><p>See <a href="#markingpersistence-section" title="Marking Persistence">the section called “Marking Persistence”</a>
  and <a href="#PeristenceCacheDepth-section" title="Marking Persistence&#10;      Cache Queue Depth">the section called “Marking Persistence
      Cache Queue Depth”</a>
  for explanation of the persistence marks.</p><p>A compiler flag exists to change the default behavior of the 
  generated code with regard to restoring the <span class="emphasis"><em>current_state</em></span>
  of persistence class instances.  To turn off this behavior and
  therefore have the default initial state, compile with
  <span><b class="command">-DMC3020_DEFAULT_STATE</b></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2492104"></a>Analysis</h2></div></div></div><div class="figure"><a id="persistdomain-figure"></a><p class="title"><b>Figure 11.1. Persistence Analysis Domain
  Chart</b></p><div class="mediaobject"><img src="persistdomain.png" alt="Persistence Analysis Domain Chart" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2492137"></a>Persist Domain Data Analysis</h3></div></div></div><p>
    </p><div class="figure"><a id="persistim-figure"></a><p class="title"><b>Figure 11.2. Persistence Class Diagram</b></p><div class="mediaobject"><img src="persistim.png" alt="Persistence Class Diagram" /></div></div><p>
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2492174"></a>PERSIST Domain Functions</h3></div></div></div><p>The <tt class="function">commit</tt> function is called to
    indicate to the domain that the application wants to commit
    instances of classes and associations to non-volatile storage.
    This in turn causes <tt class="function">NVS::insert</tt> to be called
    flushing to NVS elements from a list of instances and links that
    were queued when modified.</p><p>A return value of 0 indicates success.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">commit</b>(</code><code>void)</code>;</p></div><p>The <tt class="function">restore</tt> function is called by the
    architecture during bring-up after a power cycle.  The
    <tt class="function">restore</tt> function causes the classes contained
    in non-volatile storage to be read from store and written to the
    instance collection list.</p><p>A return value of 0 indicates success.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">restore</b>(</code>integer <var class="pdparam">class</var><code>)</code>;</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2492259"></a>Non-volatile Storage Domain Data Analysis</h3></div></div></div><p>
    </p><div class="figure"><a id="nvsim-figure"></a><p class="title"><b>Figure 11.3. Non-Volatile Storage Class Diagram</b></p><div class="mediaobject"><img src="nvsim.png" alt="Non-Volatile Storage Class Diagram" /></div></div><p>
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2492297"></a>Non-volatile Storage Domain Functions</h3></div></div></div><p>Many NVS domain functions return an integer return code.  The
    values that the return code can take are outlined in the following
    listing:
    </p><pre class="programlisting">
#define NVS_RETURN_SUCCESS    0 /* All is well.                    */
#define NVS_ERROR_BAD_OPEN   -1 /* Could not open file.            */
#define NVS_ERROR_ITEM_LONG  -2 /* Data item is too long.          */
#define NVS_ERROR_BAD_SEEK   -3 /* Could not seek correctly.       */
#define NVS_ERROR_BAD_WRITE  -4 /* File did not write correctly.   */
#define NVS_ERROR_NOT_FOUND  -5 /* Did not find searched record.   */
#define NVS_ERROR_BAD_READ   -6 /* Read incorrect length of data.  */
#define NVS_ERROR_NO_ROOM    -7 /* Not enough room for insert.     */
#define NVS_ERROR_LENGTH     -8 /* Length not correct.             */
    </pre><p>
    This can be found in the generated
    <tt class="filename">NVS_bridge.h</tt> file.  A positive value is used
    to indicate the length of a buffer.</p><p>Function <tt class="function">checksum</tt> provides a
    mathematical redundancy check on the integrity of the contents of
    the non-volatile store (NVS).  This mathematical algorithm and the
    capabilities of the function are supplied by the implementor of the
    internals of the NVS module.</p><p><tt class="function">checksum</tt> provides an integer return code
    representing an integrity check on the contents of the NVS.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">checksum</b>(</code>integer <var class="pdparam">first</var>, integer <var class="pdparam">second</var><code>)</code>;</p></div><p>The <tt class="function">defrag</tt> function coalesces deleted
    records together and written records together.  This allows for
    small fragments of free storage to be collected into a single
    contiguous free piece of storage.  This function will typically
    take significant time to run.  This time is a function of the
    specific non-volatile storage technology.</p><p><tt class="function">defrag</tt> provides an integer return
    code as listed above.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">defrag</b>(</code><code>void)</code>;</p></div><p><tt class="function">delete</tt> searches the store for an item
    matching the input and deletes it.  Deleted items cannot be
    retrieved from NVS in future invocations of <tt class="function">select</tt>
    or <tt class="function">search</tt>.  <tt class="function">delete</tt>
    chooses the item to erase based on two combinations of input
    arguments.  If the <tt class="function">delete</tt> is called with a key
    and a type, then the item in the NVS matching these key and type
    arguments is erased.  Otherwise, if non-null data is given, the data
    and type arguments are used to identify the item to delete.  When
    found, the item is marked as deleted and will not be readable from
    the store.</p><p><tt class="function">delete</tt> provides an integer return code
    as listed above.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">delete</b>(</code>integer <var class="pdparam">key</var>, integer <var class="pdparam">length</var>, string <var class="pdparam">pointer</var>, integer <var class="pdparam">type</var><code>)</code>;</p></div><p>The <tt class="function">format</tt> function erases the
    non-volatile store (NVS).  It is only to be called when it is
    desired that a new NVS be cleared and prepared for writing for the
    first time.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">format</b>(</code><code>void)</code>;</p></div><p>The <tt class="function">initialize</tt> function resets the
    internal counters of the non-volatile store.  (Note that these
    internal counters are the responsibility of the implementor of the
    internal of NVS and can contain information about the amount of
    data being used, etc.)  No application/user data is written or
    changed in the store.  This function is called automatically at
    power-up to prepare the store for access.</p><p><tt class="function">initialize</tt> provides an integer return
    code as listed above.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">initialize</b>(</code><code>void)</code>;</p></div><p>The <tt class="function">insert</tt> function adds items to the
    store.  There are four input arguments.  The first,
    <span class="emphasis"><em>key</em></span> is the lookup key to the item.  In the
    case of instance data, this key is a unique identifier for the item
    being inserted (added to the store).  <span class="emphasis"><em>length</em></span>
    is an integer representation of the length of the data byte
    sequence pointed to by pointer.  <span class="emphasis"><em>type</em></span> is the
    class type (instance or link) in integer form.  The data pointed to
    by <span class="emphasis"><em>pointer</em></span> is not modified.  If the record
    being inserted already exists in the non-volatile store, the
    existing record will be updated.  A return code provides status on
    the insert.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">insert</b>(</code>integer <var class="pdparam">key</var>, integer <var class="pdparam">length</var>, string <var class="pdparam">pointer</var>, integer <var class="pdparam">type</var><code>)</code>;</p></div><p><tt class="function">next</tt> provides a way to cycle through
    reading each item from the store one at a time.  This
    function returns the item currently being pointed to by the cursor
    (maintained inside the store).  The buffer space available on the
    calling side is passed in as the length argument.  If sufficient
    space is available in the buffer, the next item data will be copied
    into the given buffer pointed to by pointer.  The length of the
    written data is returned as the return value.  Also returned are
    the values of the key and type.  The initialize function resets the
    internal cursor to the first item in the store.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">next</b>(</code>integer * <var class="pdparam">key</var>, integer <var class="pdparam">length</var>, integer * <var class="pdparam">pointer</var>, integer * <var class="pdparam">type</var><code>)</code>;</p></div><p>The <tt class="function">select</tt> function searches the store
    for a specific item with a key and type matching those given as
    input arguments.  If a record is found that matches, it is copied
    into the data buffer pointed to by pointer.  The length argument
    provides the amount of buffer space available on the calling side.
    The actual length of the returned record (if one is returned) is
    provided in the return value.  The data behind the pointer argument
    is modified with the data found in the non-volatile store.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">select</b>(</code>integer <var class="pdparam">key</var>, integer <var class="pdparam">length</var>, string * <var class="pdparam">pointer</var>, integer <var class="pdparam">type</var><code>)</code>;</p></div><p>The <tt class="function">space_available</tt> function returns an
    integer representing the number of bytes not being used in the
    store.  This number of bytes will actually hold fewer bytes due to
    the overhead of item meta-data (key, type, etc).</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">space_available</b>(</code><code>void)</code>;</p></div><p>The <tt class="function">space_total</tt> function returns the
    overall size in bytes of the non-volatile store.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">space_total</b>(</code><code>void)</code>;</p></div><p>The <tt class="function">space_used</tt> function returns the
    number of bytes currently written in the store.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">space_used</b>(</code><code>void)</code>;</p></div><p>The <tt class="function">update</tt> function searches for a
    record in the store the same way that <tt class="function">select</tt>
    does.  When (and if) a record is found, the new data of length
    length pointed to by pointer is written into the store over the
    existing item.  Since <tt class="function">insert</tt> will perform an
    update when a record exists, it is more often used than
    <tt class="function">update</tt>.  No arguments are modified calling
    this function.</p><p><tt class="function">update</tt> provides an integer return code
    as listed above.</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">update</b>(</code>integer <var class="pdparam">key</var>, integer <var class="pdparam">length</var>, string <var class="pdparam">pointer</var>, integer <var class="pdparam">type</var><code>)</code>;</p></div><p>Function <tt class="function">version</tt> provides an integer
    return value indicating the version of the data and/or format
    of the non-volatile store (NVS).
    This versioning algorithm and the
    capabilities of the function are supplied by the implementor of the
    internals of the NVS module.  Two input arguments are used to
    provide flexible utility.</p><p><tt class="function">version</tt> provides an integer return code
    representing the version of the NVS (contents).</p><div class="funcsynopsis"><p><code class="funcdef">integer <b class="fsfunc">version</b>(</code>integer <var class="pdparam">first</var>, integer <var class="pdparam">second</var><code>)</code>;</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="persistimplementation-section"></a>Persistence Design</h2></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2492953"></a>Class-Based Create/Delete/Init</h3></div></div></div><p>Primary infrastructure changes involve the centralization
    of the create, delete and initialization of class instances.  The
    following paragraphs explain this change and its
    design.  A description of the implementation of the generated code
    follows with an explanation of the effects on speed, space and
    execution.</p><p>MC-3020 3.3 and before has a class-based create, delete, init
    design.  The generated code contains a create accessor, delete
    accessor and factory initializer for each class in the modeled
    system.  When an instance needs to be created, a routine specific
    to the class is invoked to allocate the implementation memory for
    the class instance.  The attributes for the class instance are
    given reasonable default initial values.  Identifying attributes of
    type unique_id are initialized to values certain to be unique with
    the generated system.  The initial state of the new instance state
    machine is set.</p><p>In MC-3020 3.3 and before, when an instance needs to be
    deleted, a routine specific to the class is called to deallocate
    the implementation memory for the instance and perform needed
    clean-up.</p><p>MC-3020 3.3 generates "object factory initialization"
    routines.  There is one of these methods for each class in the
    modeled domains.  These methods are called exactly once at bring-up
    time to initialize the instance memory data pool for the collection
    of instances for the class.  This routine took into consideration
    the fact that some of the instances in a collection may be
    allocated and initialized statically as preexisting instances.
    </p><p>The class-based create/delete/init approach is very flexible.
    It allows the model compiler designer the liberty of considering
    only the class in hand when generating the code.  Different
    profiles of deployment code can be generated based upon the type of
    class (passive, active, associative, having preexisting instances,
    etc).  However, having the create, delete and init accessor
    dispersed to every class is troublesome when considering a
    persistent restore operation from centralized non-volatile storage
    (NVS).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2491721"></a>Centralized Create/Delete/Init</h3></div></div></div><p>MC-3020 3.4 and beyond centralizes the create, delete and
    initialize operations.  This is accomplished by moving the
    intelligence of the class-based create/delete/init procedures into
    a class-based data structure.  This class_info array contains
    information about each class such that centralized operations can
    intelligently create, delete and initialize classes and
    instances.</p><p>The information contained in the class_info structure includes:
    </p><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><span class="term">active</span></td><td><p>The head of the
      list of active instances is used to collect the active instances
      together.</p></td></tr><tr><td><span class="term">inactive</span></td><td><p>The head of
      the list of inactive instances is also maintained and used during
      create and delete operations.</p></td></tr><tr><td><span class="term">container</span></td><td><p>Container
      refers to the head of the list of container elements used to
      maintain collections.  The base of this list is used to calculate
      indexes into the array of
      instances.</p></td></tr><tr><td><span class="term">pool</span></td><td><p>The base of the
      array representing the pool of instance data is accessible from
      the class_info array.  The base of this list also is used to
      calculate indexes into the array of
      instances.</p></td></tr><tr><td><span class="term">size</span></td><td><p>The size of the
      class (in bytes) is necessary for initialization and for
      persistence support.</p></td></tr><tr><td><span class="term">initial_state</span></td><td><p>For
      active classes, the starting state of state machines must be kept
      for initialization of newly created active
      instances.</p></td></tr><tr><td><span class="term">population</span></td><td><p>Population
      is the number of instances in the instance
      collection.</p></td></tr><tr><td><span class="term">[preexisting
      instances]</span></td><td><p>Is used when there are
      preexisting instances defined in data.  This element will inform
      the global initialization routine how many active instances to
      expect at power up so that initialization of collections may
      proceed accordingly.</p></td></tr></tbody></table></div><p>

    With the above information, it is possible to have centrally
    defined create, delete and initialization routines.  These central
    routines rely on class-specific information from the class_info
    array rather than on class-specific generated procedures.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2493296"></a>Implications to Persistence Support</h3></div></div></div><p>The persistence restore operation relies heavily upon the
    centralized create and initialization routines.  Assuming for a
    moment a system that has no preexisting instances defined in data,
    a system having persistent classes must restore the class instance
    data from a central non-volatile storage unit (NVS).</p><p>When a system powers up, it performs the standard system
    level initialization to bring up event queues and timer support and
    other system level infrastructure.  The system then initializes the
    collection mechanisms for all of the classes in the generated
    system.  This involves linking the instance storage into lists
    (singly or doubly linked).</p><p>At this point in a non-persistence supporting system the
    initialization functions would be invoked to allow application
    level user initialization to occur.  In a persistence supporting
    system, persistent class instances are restored from
    non-volatile storage before the user initialization functions are
    run.</p><p>The process of restoring class instances involves invoking
    the central create routine and populating the newly created
    instance with data from NVS.  The data in the NVS needs to be rich
    enough such that the create routine knows which type of class to
    create.  Once the type is communicated, the class_info array
    provides the necessary details to enable the correct instantiation
    of the new instance.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2493360"></a>Implementation</h3></div></div></div><p>In MC-3020 3.3 the files <tt class="filename">*_object.c</tt>
    contain methods to create, delete and perform factory
    initialization of class instances.  To compare implementations,
    view one of these files in 3.3 generated code.</p><p>In MC-3020 3.4 and beyond, these routines are centralized.
    The class_info structure is
    simply an array of pointers to elements of the structure which
    reside in the individual <tt class="filename">*_class.c</tt>
    files.</p><p>Each domain is assigned a unique number, and each class
    within a domain is assigned a unique number.  An array of
    class_info arrays exists for the system containing information for
    all classes in all domains.  During translation a domain-unique number
    is assigned to each class.  This number serves as an index into the
    class_info array thus allowing centralized create, delete, init and
    other routines to look up statistics on any class in the
    modeled system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2493407"></a>Effects</h3></div></div></div><p>Centralizing the create, delete and init functions has the
    intended effect of enabling a persistent restore operation that can
    rely on these class-independent routines (namely create).  There
    are positive side-effects of this centralization.</p><p>Code space savings is the primary positive side effect.
    Instead of three routines for each class, there are now three
    routines for the entire system.  This saves substantially on code
    size in the generated system.  This effect will be greatest on
    systems with a large number of classes.</p><p>Other positive side effects include greater flexibility in
    features such as persistence.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2493443"></a>Cost Modeling</h3></div></div></div><p>Persistence services have cost in terms of execution speed,
    instruction store space, data memory and non-volatile storage
    space.  This section enumerates those costs in as detailed a manner
    as practical.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2493456"></a>Data Memory Cost</h4></div></div></div><p>To manage the bookkeeping of persistent instances,
      additional data is maintained.  The following additional
      storage is used for each instance of each class.</p><div class="orderedlist"><ol type="1"><li><p>The <span class="emphasis"><em>instance index</em></span> is kept
        for each instance (all instances in the system).  This value
        represents the index into the array of instances.  The value is
        the index of the class instance when it was stored into NVS.
        This is required during the restore operation.
        </p></li><li><p>The <span class="emphasis"><em>class number</em></span> is required
        inside the non-volatile store.</p></li><li><p>list of pointers to link functions
        </p></li><li><p>list of class numbers
        </p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2493510"></a>Instruction Store (Code Space) Cost</h4></div></div></div><p>NVS domain:  approximated 3000 bytes (on 32 bit Intel)</p><p>PERSIST domain:  approximated 4000 bytes (on 32 bit Intel)</p><p>There is significant cost in queueing the modified instances
      to the NVS cache queue.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2493532"></a>Cost in Speed</h4></div></div></div><p>The cost in speed is largely driven by the speed of
      the non-volatile store technology.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2493545"></a>Non-volatile Memory Cost</h4></div></div></div><p>An instance in NVS is identical in size to an instance in RAM.</p></div></div></div></div><div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="Tasking-chapter"></a>Chapter 12. Tasking/Threading</h2></div></div></div><div class="highlights"><a id="Tasking-chapter-high"></a><p>MC-3020 supports running
the xtUML application within multiple tasks or threads.  The tasking
uses the underlying OS/RTOS when one exists.  MC-3020 can still run
without an OS/RTOS, but if preemptive multi-tasking is desired in
the application, it is available.  The tasking/threading
capabilities for MC-3020 are outlined here.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2494488"></a>Introduction</h2></div></div></div><p>A well-modeled xtUML application is inherently concurrent.
  Actions from any two or more instances are considered to run
  simultaneously.  This concurrency at the specification level
  simplifies the task of the developer.  Smaller bits of system can be
  modeled to run somewhat independently.  The life-cycles of classes in
  a system can be modeled mostly independently considering only their
  synchronization with other classes in the system.  For example, the
  microwave door and the turntable run concurrently and mostly without
  recognizing or caring that the other exists or is running.  If
  Developer A is modeling the door, and Developer B is modeling the
  turntable, they can do their state modeling with loose
  coupling.</p><p>To begin using the tasking/threading capability right away,
  jump to <a href="#Tasking-Marking-section" title="Marking for Tasking">the section called “Marking for Tasking”</a>.</p><p>A form of the inherent concurrency of the xtUML model can
  easily be translated and realized in a single-tasking microcontroller
  target.  In single-tasking mode, MC-3020 interleaves the state
  actions of multiple concurrent instances of executing classes.</p><p>A single-tasking deployment architecture achieves a level of
  concurrency in which state actions from actively running class
  instances are interleaved.  Such a deployment design serves well
  for applications requiring concurrency at the granularity of a
  state action.  It is light weight and fast.</p><p>However, if a finer grained concurrency is desired, it will be
  necessary to use a multi-tasking deployment system.  In a
  multi-tasking deployment environment, state actions can run in
  concurrently executing tasks or threads.  The number of currently
  executing actions can be equal to the number of executing tasks
  (instead of just one).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Tasking-Marking-section"></a>Marking for Tasking</h2></div></div></div><p>To use tasking/threading with MC-3020, the user must mark the
  feature enabled providing the "flavor" of tasking/threading provided
  by the underlying operating system (OS) or real-time operating system
  (RTOS).  Use the marking described <a href="#Marking-EnablingTasking-section" title="Enabling&#10;      Multi-Tasking">the section called “Enabling
      Multi-Tasking”</a>.</p><p>Once the tasking/threading capability has been enabled, the
  priorities of the desired tasks must be established.  Various
  operating systems (OSes) and real-time operating systems (RTOSes) use
  different symbology for setting priority.  For example, Nucleus PLUS
  uses integer numbers between 0 and 255 to indicate the priority of a
  task.  (0 is the highest priority; 255 is the lowest.) Use the
  marking function described in <a href="#Marking-TaskPriority-section" title="Establishing Multi-Task Priority">the section called “Establishing Multi-Task Priority”</a> to set the priority of the
  tasks in the xtUML generated system.</p><p>Classes must be mapped to the tasks identified with the marking
  functions above.  Use the marking function described in <a href="#Marking-MappingClassesToTasks-section" title="Mapping Classes to Tasks/Threads">the section called “Mapping Classes to Tasks/Threads”</a> to map classes to
  tasks.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Tasking-Prioritization-section"></a>Prioritization</h2></div></div></div><p>The primary reason for tasking in an xtUML modeled system
  involves the deployment of prioritization in the generated code.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="Tasking-PriorityGeneration-section"></a>Priority in the
    Generated Code</h3></div></div></div><p>An xtUML model may be inherently concurrent, but it is not
    inherently prioritized.</p><p>Simple prioritization of execution of a
    translated xtUML model can be achieved without multi-tasking.
    Events can be prioritized to modify the sequencing of state
    actions.  MC-3020 provides event prioritization.</p><p>In a single tasking environment, a state action cannot be
    preempted.  Therefore, a single task deployment environment is
    limited by the duration of the longest state action.  Without
    preemption, a higher priority action may need to wait the entire
    duration of a state action of lower priority processing.  Sometimes
    this is not an issue.</p><p>However, in many embedded applications the limits of a single
    task cannot be tolerated.  We must map the xtUML application onto a
    multi-tasking/multi-threading architecture.  By doing so, it is
    possible to map processing to various tasks based upon the required
    priorities.  Higher priority action processing can be designed to
    preempt lower priority actions.  We can take control away from the
    lower priority action and context switch into the higher priority
    action running in a higher priority task.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="Tasking-Mapping-section"></a>Mapping to Tasks</h3></div></div></div><p>There are many possible strategies for mapping the components
    of an xtUML application to tasks.  Event-based strategies and
    strategies based upon sequences of actions have been implemented
    successfully.  MC-3020 has supported event based prioritization
    since version 2.  As of MC-3020 version 4, prioritization using
    tasks/threads is supported.  The mapping of xtUML artifacts to
    these tasks/threads is by class.  Groups of classes are mapped to
    the tasks/threads running in the generated system.</p><p>xtUML model marking is used to identify which classes are
    translated to run in which tasks in the deployment target.  Each
    class is marked identifying the task in which its generated code
    runs.  The priority of the action processing of the class is used
    to determine an appropriate task.  Higher priority classes get
    mapped to higher priority tasks.  This separation allows for the
    processing of higher priority classes to preempt the processesing
    of lower priority classes.</p><p>Classes with state charts requiring low latency response to
    application events are mapped to high priority.  Classes with
    little or no requirement for quick response are mapped to lower
    priority RTOS tasks.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2495335"></a>How Many Tasks?</h3></div></div></div><p>The number of tasks required by the application is largely
    driven by prioritization.  Concurrency plays a part in
    determining the number of tasks needed.  The mapping to
    tasks must be accomplished with a clear understanding of both the
    xtUML application and of the deployment target hardware and
    RTOS.</p><p>A simple starting point is to have one task for each
    required level of priority.  Map all classes having the same
    priority to the same task.  For example map classes with tight
    coupling to time sensitive hardware to high priority task(s).
    Map classes that do non-critical "background" types of processing
    to a low priority task.  Map everything else to a normal priority
    task.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2495369"></a>Data Access Issues</h3></div></div></div><p>In an xtUML application concurrency is assumed unless
    purposefully sequenced.  Access to data that is shared between
    various classes/actions/functions must be synchronized.  A
    simple, single-tasking deployment target may hide synchronization
    issues.  A multi-tasking environment will not hide these modeling
    defects and indeed may aggravate them.  If an xtUML application
    has not been properly synchronized, a truly preemptive
    multi-tasking kernel can uncover the modeling deficiencies.</p><p>Note that it is wise to map classes with strong processing
    and data interaction (coupling) into the same task.  An improper
    mapping of classes to tasks can increase the overhead of
    processing by introducing undue task switching.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Tasking-Deployment-section"></a>Tasking/Threading in the Generated Code</h2></div></div></div><p>MC-3020 interfaces to the tasking/threading capabilities of
  the underlying OS/RTOS through a single interface layer module.
  The interface module is generated into the generated source of the 
  system node into a file called <tt class="filename">sys_thread.c</tt>.</p><p>The tasking/threading interface consists of six interfaces.
  One interface provides for initialization
  (<tt class="function">InitializeThreading</tt>).  Another interface
  provides for creating threads
  (<tt class="function">thread_create</tt>).  Two interfaces allow
  for the locking and unlocking of shared resources such as event
  and instance queues (<tt class="function">mutex_lock/unlock</tt>).
  Two final interfaces allow for the class activities in a task to go
  "non-busy" using no cycles when there is no work to do
  (<tt class="function">nonbusy_wait/wake</tt>) and to "wake up" when new
  work arrives.</p><p>The resources that are protected by the locking and unlocking
  interfaces include instance event queue, self event queue, collection
  element free list, non-busy lock, serialization lock, instance
  queues, timers and interleaved bridges.</p></div></div><div class="appendix" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="Installation-appendix"></a>Appendix A. Deployment</h2></div></div></div><div class="sect1" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2494914"></a>Installation</h2></div></div></div><div class="highlights"><a id="Installation-appendix-high"></a><p>Find here
step by step instructions for installing MC-3020 onto the
development platform.</p></div><p>Documentation is found in the <tt class="filename">docs</tt>
directory of the installed model compiler.  Directions presented by
the installation program that differ from this manual supersede the
instructions listed here.  The installation program will always
provide the most recent and timely installation information.
The text in the on-line user guide at <a href="http://roxsoftware.com/ug/" target="_top">
<i class="citetitle">MC-3020 User Guide</i></a> will be even
more up to date.</p><p>Uninstall any previous version of MC-3020 before beginning
the installation process.  There is an exception to this.  If the
version of MC-3020 on your computer is between version 3.2.0
and 3.3.0, then do not unintall.  In this case skip the uninstall
step and install right over the top of your previous installation.</p><p>Note MC-3020 will need to be reinstalled
after upgrading Nucleus BridgePoint.  MC-3020 relies on components within
Nucleus BridgePoint.  This uninstall/reinstall must occur any time that Nucleus BridgePoint
is altered substantially (e.g upgrade, change in location of
model repository).  ROX_* environment
variables need to be set to point to the
correct (new) locations.  Specifically, the variables
ROX_PT_HOME and ROX_PT_REPOSITORY_HOME need to 
link to the correct directories.  These variables use the
old 8.3 format names.  <span><b class="command">DIR /X</b></span> is the
DOS command to see the underlying file and path names.</p><p>Note that MC-3020 may not install onto a system that does not
have the appropriate licensing.</p><div class="sect2" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2495925"></a>Windows XP/2000/NT</h3></div></div></div><p>Follow these steps and the directions on the screen.
  Cygwin and MC-3020 will be installed as needed.</p><div class="orderedlist"><ol type="1"><li><p>On XP/2000/NT, log in as administrator.</p></li><li><p>Uninstall the old version of MC-3020 (if you have
    not done so already).</p></li><li><p>Insert MC-3020 compact disk into the
    CD ROM drive of the development platform.</p></li><li><p>If necessary, select Program-&gt;Run under the Start
    button.</p></li><li><p>Run the Setup program (setup.exe)
    on the CD.</p></li><li><p>Follow the instructions.</p></li><li><p>Reboot.</p></li></ol></div><div class="sect3" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2495981"></a>Cygwin Support</h4></div></div></div><p>Excellent shell, compiler and build environment toolkit
    technology exists in the freely available 
    <a href="http://www.cygwin.com/" target="_top">
    <i class="citetitle">Cygwin</i></a>.  MC-3020 3.1+ has
    Cygwin (and ksh) support right on the CD.  Installation
    is automatic.</p><p>If you already have Cygwin installed, the MC-3020 installation
    CD will detect it and not install Cygwin.  However, you may
    need to upgrade your Cygwin installation to include packages
    such as make, perl and xsltproc if you do not have them.</p><p>Permissions issues with Cygwin can pose a problem.  Once
    Cygwin is installed, executables may be configured to allow
    only the owner of the file to read them and execute them.
    By default, Nucleus BridgePoint is set such that only an administrator can
    run the <tt class="filename">repository_bin</tt> executables.
    Keep this in mind if you seem to be having difficulty getting
    some build steps to execute correctly.  Access can be
    granted to the executables using the <span><b class="command">chmod</b></span>
    command (in the bin directory in question type <span><b class="command">chmod
    ugo+rx *.exe</b></span>).</p><p>The 3.1+ release CD of MC-3020 has automatic installation
    of Cygwin (with ksh).  These instructions will serve to document
    where these files are expected to be.</p></div></div><div class="sect2" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2496056"></a>Solaris</h3></div></div></div><p>Follow these steps and the directions on the screen.</p><div class="orderedlist"><ol type="1"><li><p>Insert MC-3020 compact disk into the
    CD ROM drive of the development platform.</p></li><li><p>Ensure that CD is mounted as an ISO-9660
    type file system.</p></li><li><p>Run the setup.ksh program on the CD.</p></li><li><p>Follow the instructions.</p></li><li><p>Establish environment variables as directed
    by the installation program.</p></li></ol></div></div></div></div><div class="appendix" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="QuickStart-appendix"></a>Appendix B. Quick Start</h2></div></div></div><div class="highlights"><a id="QuickStart-appendix-high"></a><p>Get MC-3020 up and
running right ``out of the box''.  Instructions are provided
here to build a sample system.  It is a simple matter to substitute
a different model for the sample provided here.</p></div><div class="sect1" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2495578"></a>HOWTO</h2></div></div></div><p>Attention to the following instructions will ensure
  the most productive installation and evaluation.</p><p>First, install MC-3020.  See <a href="#Installation-appendix" title="Appendix A. Deployment">Appendix A, <i>Deployment</i></a>
  for installation instructions.</p><div class="sect2" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2496400"></a>Fully Automatic Demonstration</h3></div></div></div><p>MC-3020 comes with a script that will translate two domains
  and compile them automatically.  On Windows, this will work with
  no modifications when using GNU gcc.  (By changing only the generated
  <tt class="filename">Makefile.user</tt>, the source can be recompiled
  with Microsoft Visual C/C++.)  On Sun, this will work
  with no modification when using GNU gcc.</p><p>This example uses a pair of xtUML domains to model a chemical
  sampling system.  The autosampler example model is coupled with
  a domain called experiment.</p><div class="orderedlist"><ol type="1"><li><p>Import <tt class="filename">as2.sql</tt> and
    <tt class="filename">exp.sql</tt> found in the directory
    <tt class="filename">$ROX_MC_ROOT_DIR/examples/ae/</tt>
    in the MC-3020 installation.  Create a configuration view.
    (When importing a model into Nucleus BridgePoint Model Builder, remember
    that all subsystems, including
    TIM, must be deleted before importing the .sql.)</p></li><li><p>Start up a shell (Cygwin bash).</p></li><li><p>Execute
    <span><b class="command">$ROX_MC_ROOT_DIR/examples/ae/aedemo</b></span>.
    </p></li></ol></div></div><div class="sect2" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2496470"></a>Step By Step</h3></div></div></div><div class="orderedlist"><ol type="1"><li><p>If translating the autosampler example model provided,
    import <tt class="filename">as2.sql</tt> and <tt class="filename">exp.sql</tt>
    found at <tt class="filename">$ROX_MC_ROOT_DIR/examples/ae/*.sql</tt>
    in the MC-3020 installation.  Create a configuration view.
    (When importing a model into Nucleus BridgePoint Model Builder, remember
    that all subsystems, including
    TIM, must be deleted before importing the sql.)</p></li><li><p>Start up a shell.</p></li><li><p>Execute <span><b class="command">$ROX_MC_BIN_DIR/rox_init_node</b></span>
    to create an
    application node.  Provide a directory name for the application
    node.  Be sure to note any directions given
    as output from this command.</p></li><li><p>Create a domain node by changing directories into
    your application node (created above) and executing <span><b class="command">make
    dom_node domain=xxx</b></span> where <span><b class="command">xxx</b></span> is
    the name of the model repository in Nucleus BridgePoint Model Builder.  If translating
    the autosampler model provided, the command will be
    <span><b class="command">make dom_node domain=as2</b></span> and
    <span><b class="command">make dom_node domain=exp</b></span></p></li><li><p>Edit the system and domain marking files.
    If translating the example autosampler model, copy
    bridge.clr, datatype.clr, registry.clr and system.clr from
    <tt class="filename">$ROX_MC_ROOT_DIR/examples/ae/</tt>
    to
    (node)<tt class="filename">/system/color/</tt>.
    Copy as2_domain.clr and as2_event.clr from
    <tt class="filename">$ROX_MC_ROOT_DIR/examples/ae/</tt>
    to
    (node)<tt class="filename">/as2/color</tt>.
    These are pre-edited
    marking files that register the domains, wire the bridges and
    identify initialization and bridge objects.  Default system
    and domain parameters are established.</p><p>If necessary for other models, edit the marking files in
    the directory (node)<tt class="filename">/system/color</tt> and
    (node)<tt class="filename">/xxx/color</tt>.  The
    model compiler provides reasonable defaults for all
    unmarked artifacts.  However, the defaults do not include
    bridging and registration.  See examples in
    <tt class="filename">$ROX_MC_ROOT_DIR/examples/ae/gendcode</tt>.
    </p><div class="itemizedlist"><ul type="disc"><li><p>Register xtUML domains and realized domains in
      <tt class="filename">register.clr</tt>.  This registration process
      provides a shorthand name for a domain.  The name and
      repository of the model (or code) can change; the
      registration provides indirection between the models and the
      translated name space and version space.</p></li><li><p>To wire bridges across domains (including
      realized domains), edit
      <tt class="filename">bridges.clr</tt>.</p></li><li><p>Provide data type precision information in
      <tt class="filename">datatype.clr</tt>.</p></li><li><p>To specify collection sizes for extents, edit
      <tt class="filename">domain.clr</tt>.  Tracing switches as well
      as other knobs and dials are
      specified in this file.</p></li><li><p>Constrain extent sizes by editing
      <tt class="filename">object.clr</tt>.</p></li></ul></div></li><li><p>Generate the ANSI C bridge skeletons by
    invoking
    <span><b class="command">make bridge_skel domain=as2 ee=CARPIO</b></span> and
    <span><b class="command">make bridge_skel domain=as2 ee=SPPIO</b></span> and
    <span><b class="command">make bridge_skel domain=as2 ee=UI</b></span>
    </p></li><li><p>Generate the ANSI C source code by executing
    <span><b class="command">make gen_all</b></span>.</p></li><li><p>Copy (node)<tt class="filename">/system/skel/*.h</tt> to
    (node)<tt class="filename">/system/user/include</tt>.</p></li><li><p>Copy (node)<tt class="filename">/system/skel/*.c</tt>
    to (node)<tt class="filename">/system/user/source</tt>.</p></li><li><p>Copy sys_user_co.c from
    <tt class="filename">$ROX_MC_ROOT_DIR/examples/ae/</tt>
    to
    (node)<tt class="filename">/system/user/source/</tt>.</p></li><li><p>Copy sys_user_co.h from
    <tt class="filename">$ROX_MC_ROOT_DIR/examples/ae/</tt>
    to
    (node)<tt class="filename">/system/user/include/</tt>.</p></li><li><p>Frameworks for bridge and operation code is
    generated into these skeleton directories.  Simply add your own
    bridge and operation source code where directed in the
    generated file.</p></li><li><p>Compile the C source code by executing
    <span><b class="command">make all</b></span>.</p></li><li><p>The executable, 
    <tt class="filename">rox.exe</tt>, will be at
    (node)<tt class="filename">/bin/rox.exe</tt>.  Run it on the NT host
    and see the state trace and action language trace.  For
    the autosampler, the run ends waiting for the carousel
    stepper motor (which does not exist) to move the
    carousel.</p></li></ol></div></div></div></div><div class="appendix" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="AnalysisGuide-appendix"></a>Appendix C. Analysis Guide</h2></div></div></div><div class="highlights"><a id="AnalysisGuide-appendix-high"></a><p>MC-3020
levies certain restrictions upon the analyst.  These restrictions
and advice for capitalizing upon MC-3020 features are
provided.</p></div><div class="sect1" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2496246"></a>Restrictions and Limitations</h2></div></div></div><p>
  </p><div class="itemizedlist"><ul type="disc"><li><p>Cannot number an event with 0.</p></li><li><p>Prioritization of polymorphic events is not
    supported.</p></li><li><p>No dynamic memory allocation.  System storage space
    for all instances is pre-allocated at start-up.  This implies
    marking the OIM to define the maximum number of instances needed
    for each object.  Note that MC-3020 intelligently determines
    rational defaults for instance and event populations.  Marking
    is used to dial these in tightly.</p></li><li><p>Some platforms have no real time clock.  Therefore
    date and time are not available in standard Gregorian or Caesarian
    form.</p></li><li><p>State machines are optimized for speed rather than
    space.</p></li><li><p>Events across bridges are not
    allowed.</p></li><li><p>Navigations of composed relationship must explicitly
    use the ``real'' (non-composed) relationship
    formalizations.</p></li><li><p>When altering a relationship formalized by combined
    referential attributes, MC-3020 does not (currently) propagate
    effect to all relationships which are involved in the definition of
    the combined referentials.  This differs from MC-201x behavior.  In
    this case the analysis model must assume responsibility for
    propagating combined referential influence, which will be forward
    compatible.</p></li><li><p>Relationship conditionality is not enforced by
    the model compiler.</p></li><li><p>Actions may not leave identifying attributes
    inconsistent beyond the end of any action.</p></li><li><p>Blind selections following a create and in the same
    scope as the create may not see the newly created instance in the
    extent.</p></li><li><p><span><b class="command">create object instance of</b></span>
     <span class="emphasis"><em>keyletters</em></span> (create with no return
    value) is allowed only when the identifier of
    object <span class="emphasis"><em>keyletters</em></span> is of type
    unique_ID.</p></li><li><p>The implementation of string expressions
    is somewhat inelegant.  Strings in expressions are limited to simple
    binary operations.  For example
    </p><pre class="programlisting">company = "Mentor" + "Graphics" + "Corp.";</pre><p>
    results in a compilation error.  The alternative,
    </p><pre class="programlisting">company = "Mentor" + "Graphics";</pre><p>
    </p><pre class="programlisting">company = company + "Corp.";</pre><p>
    must be used to
    work around this shortcoming.</p></li><li><p>There is no support for ``N to N + 1'' release
    compatibility.  Changes to a model result in changes in the code,
    including event numbers, state numbers, etc.  The registration
    theme is introduced to pave the way for future N+1 release
    capability.</p></li></ul></div><p>
  </p></div></div><div class="appendix" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="Background-appendix"></a>Appendix D. Background</h2></div></div></div><div class="highlights"><a id="Background-appendix-high"></a><p>This appendix begins
by providing a general overview of model compilers (sometimes
referred to as the <span class="emphasis"><em>software architecture</em></span>)
followed by a brief description of the major components of MC-3020.
Next, a more detailed look is taken at the two types of tasks found
in the MC-3020 architecture and how they interact.  Finally, the
general operational nature of each task type is described. The intent
is to provide the reader with a complete, high level view of the
MC-3020 architecture, sufficient to provide a context for the rest
of this manual.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2496363"></a>Model Compilers (Software Architectures)</h2></div></div></div><div class="highlights"><p>This section provides a general overview of how
  model compilers fit into the Shlaer-Mellor method.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2497286"></a>Shlaer-Mellor Development</h3></div></div></div><p>The Shlaer-Mellor approach to software development begins by
    partitioning the system into separate subject matters referred to
    as domains.  Each domain is then analyzed using xtUML modeling
    and finally the system is implemented by translating
    the xtUML models into the chosen implementation technology (e.g.
    language, operating system, custom hardware) using the model
    compiler.</p><p>The software architecture is that domain which deals with the
    subject matter of designing and implementing the system.  It
    abstracts the design and implementation patterns appropriate for
    the system and defines mapping rules between the xtUML models and
    these design and implementation patterns.  This approach provides a
    uniform set of data, function, and control abstractions that are
    used system wide and forms the basis for translating the xtUML models
    based on an automation of the mapping rules.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2497659"></a>Software Architecture Components</h3></div></div></div><p>A software architecture is made up of three main components:
    mechanisms, rule files (formerly archetypes) and marks.
    In addition, build and
    diagnostic components are provided to facilitate constructing and
    debugging the system.  These components are described in the
    following subsections.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2497679"></a>Mechanisms</h4></div></div></div><p>A mechanism is architecture functionality that is specified,
      designed, coded, and compiled to work with all xtUML models.  It is
      not customized on an xtUML element boundary.  Examples of mechanisms
      in an object-oriented ANSI C model compiler include code for 
      managing circular queues and modules written to perform set
      manipulation in a generic fashion.</p><p>In some architectures, pre-compiled mechanisms are not
      necessary.  All code is generated from rule files or included
      in uncompiled source form.  This is true of MC-3020.</p><p>MC-3020 is purely ANSI C and generates code that can be
      compiled by any compiler compliant with the ANSI standard.  The
      core model compiler now uses no libraries or system functions at
      all.  Generated code is pure native C.  All string manipulation
      library functions (memcpy, strcpy, strcat and related) used in
      previous versions have been eliminated.  Native C functions have
      replaced these system calls.  This has been accomplished in such
      a way that a user can redefine the functions with a small
      rule file change or macro definition.</p><p>This change makes it simpler and easier to integrate with
      compilers of various makes and models and manufacturers.  In
      addition, some simpler compilers will link in an entire library
      of system functions when any single function is accessed from
      the library.  Only <tt class="filename">stdio.h</tt> remains as
      exposure on this front.</p><p><tt class="filename">stdio.h</tt> is included simply for convenience
      during debug (for <span><b class="command">printf</b></span>, etc).  All generated
      code is simple, native C.  When integrating realized external
      entities and timer services (TIM), other system libraries will
      be necessary.  However, the core xtUML generated code remains
      simple ANSI C.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2497761"></a>Rule Files (a.k.a. archetypes, templates)</h4></div></div></div><p>A rule file is a combination of an implementation pattern
      and translation rules for filling out that pattern based upon
      specifics of the xtUML models.  Thus a rule file is designed to be
      customized on an xtUML element boundary.  An example of a rule file
      in an object-oriented ANSI C model compiler is the code pattern for
      a struct that will be used to represent xtUML classes along with the
      translation rules for populating that code pattern with such xtUML
      elements as object name, attribute name, and valid events for that
      object.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2497783"></a>Marks</h4></div></div></div><p>When there is more than one software architecture element
      into which an xtUML element can be translated,
      <span class="emphasis"><em>marks</em></span> (formerly "colors") are used to
      indicate which translation
      to make.  The name ``mark'' comes from the visualization of using
      a highlighter pen to mark each element that has a particular
      property. Marks are used to direct the translation to select one
      of two or more branches in the translation rules.  It is through
      marking that design decisions are injected during the translation
      process.</p><p>An example of the type of design information that is
      specified through marking is the mapping of analysis data types
      into implementation (e.g., C) data types.  Clearly, this is
      information that does not belong in either the xtUML models or the
      model compiler itself.  Such information is maintained
      outside the model compiler and models in marking tables that are
      accessed during the translation process.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2497833"></a>Additional Components</h3></div></div></div><p>In addition to the three basic components of a model
    compiler, the mechanisms, rule files, and marks, there are also
    two tools which come with an architecture to facilitate the
    translating and building of the system and provide some diagnostic
    capabilities for debugging the system.  These are:
    </p><div class="itemizedlist"><ul type="disc"><li><p>build tools</p></li><li><p>diagnostic tools</p></li></ul></div><p>
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2497866"></a>Model Compiler Analogy</h3></div></div></div><p>Just as assembly language is translated into machine code,
    and a high level language is translated into assembly code (which
    is then translated into machine code), the xtUML models and their
    translation into a high level language can be viewed as the next
    evolutionary step in language development.  The xtUML models now
    become the new ``programming language'' and the software architecture
    the new ``compiler''. This approach is referred to as model based
    translative development (MBTD).</p><p>Applying this analogy to the model compiler components,
    the mechanisms represent the run-time library that comes with a
    conventional compiler to provide the functions necessary to
    successfully execute the compiled code in the chosen
    implementation environment.  Likewise, the rule files represent the
    translation program or compiler that actually translates the high
    level source code input to assembly code output.</p><p>
    <a href="#model-compiler-figure" title="Figure D.1. &#10;    Model Compiler Analogy with Nucleus BridgePoint Tool Set">Figure D.1, “
    Model Compiler Analogy with Nucleus BridgePoint Tool Set”</a>
    shows an overview of how the model compilation process works in the
    context of the Nucleus BridgePoint tool set.  The xtUML models are read from the
    repository of the Nucleus BridgePoint Model Builder and the translation rule files are
    fed into the Nucleus BridgePoint Generator.</p><div class="figure-float"><div class="figure"><a id="model-compiler-figure"></a><p class="title"><b>Figure D.1. 
    Model Compiler Analogy with Nucleus BridgePoint Tool Set</b></p><div class="mediaobject"><img src="mcanalog.png" alt="Model Compiler Analogy with Nucleus BridgePoint Tool Set" /></div></div></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2497944"></a>Components</h2></div></div></div><div class="highlights"><p>This section provides a brief overview of the
  MC-3020 architecture components by describing the Mechanisms,
  Archetypes, Marks, Build Tools, and Diagnostic Tools that make up
  the product.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2497708"></a>Mechanisms</h3></div></div></div><p>The mechanisms for MC-3020 are implemented as ANSI C
    source code.  This code compiles at build time to provide
    support for:
    </p><div class="itemizedlist"><ul type="disc"><li><p>collections</p></li><li><p>xtUML timer interfaces</p></li></ul></div><p>
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2497988"></a>Archetypes</h3></div></div></div><p>The Nucleus BridgePoint translation approach employs two different types of
    rule files, <span class="emphasis"><em>structural rule files</em></span> and
    <span class="emphasis"><em>fragment generation</em></span> rule files.  Structural
    rule files produce the structure of the system (e.g. structure
    definitions, function definitions, state transition tables, etc.).
    Fragment generation rule files are used during the translation of
    the action language modeling the processing of the system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2498018"></a>Marks</h3></div></div></div><p>MC-3020 provides the capability to direct the translation of
    the xtUML models by marking them to:
    </p><div class="itemizedlist"><ul type="disc"><li><p>register xtUML and non-xtUML
      domains,</p></li><li><p>identify external entities as either xtUML or non-xtUML
      domains,</p></li><li><p>identify bridge objects for use by non-xtUML
      domains,</p></li><li><p>assign domain and system wide data type
      precisions,</p></li><li><p>tag initialization objects and objects to be
      excluded from translation,</p></li><li><p>establish limits to the extents of instance
      collections,</p></li></ul></div><p>
    A detailed description of these capabilities is provided in
    <a href="#Marking-chapter" title="Chapter 4. Marking">Chapter 4, <i>Marking</i></a>
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2498081"></a>Build Tools</h3></div></div></div><p>MC-3020 is shipped with a set of build tools implemented as
    shell scripts that can be used to translate models and compile and
    link the resulting code.  These tools rely heavily on the
    <span><b class="command">make</b></span> program.  A detailed description of the
    build tools including instructions for their use is provided in
    <a href="#TranslationBuild-chapter" title="Chapter 5. Translation and Build">Chapter 5, <i>Translation and Build</i></a></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2498106"></a>Capabilities</h3></div></div></div><p>After an application has been specified with Shlaer-Mellor
    xtUML models, MC-3020 provides the capability to translate those
    models into ANSI C source code.  This source can be compiled, linked
    and located to produce an executable load image.  This executable
    can be run on various targets.  It can be converted into an
    Intel Hex format file or Motorola S-record format file for
    loading into an EPROM or flash memory.</p></div></div></div><div class="appendix" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="peiinitlisting-appendix"></a>Appendix E. PEI Test Case Setup</h2></div></div></div><div class="highlights"><a id="peiinitlisting-appendix-high"></a><p>The PEI test
case setup domain function is listed here in it entirety.
</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2497230"></a>PEI Test Case Initialization Function Listing</h2></div></div></div><p>
  </p><div class="figure"><a id="peiinit-figure"></a><p class="title"><b>Figure E.1. PEI Model Init Function</b></p><div class="informalexample"><p>
  </p><pre class="programlisting">
//
// Set up instances for existance test later on.
//
create object instance a of A;  // extras to see in PEIs
create object instance a of A;
create object instance a of A; a.i = 1;
create object instance b of B; b.i = 2;
relate a to b across R1;
create object instance a of A; a.i = 3;
create object instance b of B; b.i = 4;
relate b to a across R1;
create object instance a of A; a.i = 5;
create object instance b of B; b.i = 6;
relate a to b across R1;
create object instance b of B;  // extra to see it in PEIs

create object instance c1 of C; c1.cID = 1;
create object instance c2 of C; c2.cID = 2;
create object instance c3 of C; c3.cID = 3;
create object instance c4 of C; c4.cID = 4;
create object instance c5 of C;  // extra
create object instance d1 of D;  // extra
create object instance d2 of D; d2.name = "DeeTwo";
relate c1 to d2 across R2;
relate d2 to c2 across R2;
relate d2 to c3 across R2;
relate c4 to d2 across R2;

create object instance e1 of E; e1.eID = 1; e1.ratio = 0.314;
create object instance e0 of E; e1.eID = 100; e1.ratio = 0.1;
create object instance e2 of E; e2.eID = 2; e2.ratio = 2.718;
create object instance f3 of F; f3.fID = 3; f3.enabled = true;
create object instance f2 of F; f2.fID = 2; f2.enabled = false;
create object instance f1 of F; f1.fID = 1; f1.enabled = true;
create object instance g1 of G; g1.gID = 1;
create object instance g2 of G; g2.gID = 2;
create object instance g3 of G; g3.gID = 3;
create object instance g4 of G; g4.gID = 4;
relate e1 to f1 across R3 using g1;
relate f2 to e1 across R3 using g2;
relate f3 to e2 across R3 using g3;
relate e1 to f3 across R3 using g4;

create object instance h1 of H; h1.hID = 1;
create object instance h2 of H; h2.hID = 2;
create object instance h of H; h.hID = 99;  // extra to see in PEIs
create object instance h3 of H; h3.hID = 3;
create object instance h4 of H; h4.hID = 4;
relate h1 to h2 across R4.'precedes';
relate h2 to h3 across R4.'precedes';
relate h4 to h3 across R4.'follows';

create object instance i4 of I; i4.iID = 400; i4.common = 400;
create object instance i3 of I; i3.iID = 300; i3.common = 300;
create object instance i2 of I; i2.iID = 200; i2.common = 200;
create object instance i1 of I; i1.iID = 100; i1.common = 100;
create object instance j1 of J; j1.jID = 2; j1.specialJ = 2;
create object instance k1 of K; k1.kID = 11; k1.specialcommon = 11;
create object instance k2 of K; k2.kID = 22; k2.specialcommon = 22;
create object instance k3 of K; k3.kID = 33; k3.specialcommon = 33;
create object instance l2 of L; l2.lID = 222; l2.specialL = 222;
create object instance l3 of L; l3.lID = 333; l3.specialL = 333;
create object instance l1 of L; l1.lID = 111; l1.specialL = 111;
relate i1 to j1 across R5;
relate i2 to k3 across R5;
relate k2 to i3 across R5;
relate i4 to k1 across R5;
relate l1 to k1 across R6;
relate l3 to k2 across R6;
relate k3 to l2 across R6;

create object instance o1 of O; o1.oID = 1; o1.voo = "Kenny";
create object instance o2 of O; o2.oID = 2; o2.voo = "Cort";
create object instance o3 of O; o3.oID = 3; o3.voo = "Amy";
create object instance o4 of O; o4.oID = 4; o4.voo = "Ellen";
create object instance o5 of O; o5.oID = 5; o5.voo = "Brad";
relate o1 to o2 across R8.'teaches'; // Kenny teaches Cort.
relate o2 to o3 across R8.'teaches'; // Cort teaches Amy.
relate o4 to o2 across R8.'learns from'; // Ellen learns from Cort.
relate o5 to o2 across R8.'learns from'; // Brad learns from Cort.

create object instance n1 of N; n1.nID = 1; n1.name = "Pete";
create object instance n2 of N; n2.nID = 2; n2.name = "Dave";
create object instance n3 of N; n3.nID = 3; n3.name = "Alex";
create object instance n4 of N; n4.nID = 4; n4.name = "Jenn";
create object instance n5 of N; n5.nID = 5; n5.name = "Cale";
create object instance n6 of N; n6.nID = 6; n6.name = "Chris";
create object instance m1 of M; m1.mID = 1; m1.department = "SW";
create object instance m2 of M; m2.mID = 2; m2.department = "SW";
create object instance m3 of M; m3.mID = 3; m3.department = "HW";
create object instance m4 of M; m4.mID = 4; m4.department = "MEC";
create object instance m5 of M; m5.mID = 5; m5.department = "MEC";
relate n1 to n3 across R7.'manages' using m1;   // Pete manages Alex.
relate n1 to n4 across R7.'manages' using m2;   // Pete manages Jenn.
relate n5 to n2 across R7.'works for' using m3; // Cale works for Dave.
relate n1 to n6 across R7.'works for' using m4; // Pete works for Chris.
relate n6 to n2 across R7.'manages' using m5; // Chris manages Dave.

create object instance p1 of P; p1.eyedee = "Rox";
create object instance p2 of P; p2.eyedee = "Bita";
create object instance p3 of P; p3.eyedee = "Tina";
create object instance q1 of Q; q1.deeeye = "Shane";
create object instance q2 of Q; q2.deeeye = "Rusty";
create object instance q3 of Q; q3.deeeye = "Cort";
create object instance r1 of R; r1.city = "Indianapolis";
create object instance r2 of R; r2.city = "Lockport";
create object instance r3 of R; r3.city = "Battleground";
relate p1 to q3 across R9 using r1;
relate q2 to p2 across R9 using r3;
relate p3 to q1 across R9 using r2;

create object instance s1 of S; s1.s = "Rox";
create object instance s2 of S; s2.s = "Jacqui";
create object instance t1 of T; t1.t = "Clare";
create object instance t2 of T; t2.t = "Katrina";
create object instance t3 of T; t3.t = "Colleen";
create object instance t4 of T; t4.t = "Hannah";
create object instance t5 of T; t5.t = "Ruby";
create object instance u5 of U; u5.s = "Oct";
create object instance u4 of U; u4.s = "Aug";
create object instance u3 of U; u3.s = "Apr";
create object instance u2 of U; u2.s = "Dec";
create object instance u1 of U; u1.s = "Nov";
relate s1 to t4 across R10 using u2;
relate s1 to t5 across R10 using u1;
relate t1 to s2 across R10 using u5;
relate t2 to s2 across R10 using u4;
relate s2 to t3 across R10 using u3;

create object instance w1 of W; w1.name = "Cort";
create object instance w2 of W; w2.name = "Rox";
create object instance w3 of W; w3.name = "Sean";
create object instance w4 of W; w4.name = "Jacqui";
create object instance v1 of V; v1.year = 1988;
create object instance v2 of V; v2.year = 1990;
relate w1 to w2 across R11.'is husband of' using v1;
relate w4 to w3 across R11.'is wife of' using v2;

// friends and friendships
create object instance x1 of X; x1.name = "Cort"; x1.age = 39;
create object instance x2 of X; x2.name = "Rox"; x2.age = 38;
create object instance x3 of X; x3.name = "Sevina"; x3.age = 35;
create object instance x4 of X; x4.name = "Joe"; x4.age = 43;
create object instance x5 of X; x5.name = "Scott"; x5.age = 42;
create object instance x6 of X; x6.name = "Jason"; x6.age = 31;
create object instance y1 of Y; y1.duration = 1; y1.closeness = 10;
create object instance y2 of Y; y2.duration = 2; y2.closeness = 20;
create object instance y3 of Y; y3.duration = 3; y3.closeness = 30;
create object instance y4 of Y; y4.duration = 4; y4.closeness = 40;
create object instance y5 of Y; y5.duration = 5; y5.closeness = 50;
create object instance y6 of Y; y6.duration = 6; y6.closeness = 60;
create object instance y7 of Y; y7.duration = 7; y7.closeness = 70;
create object instance y8 of Y; y8.duration = 8; y8.closeness = 80;
create object instance y9 of Y; y9.duration = 9; y9.closeness = 90;
// Cort's friends
relate x1 to x2 across R12.'is buddy of' using y1;
relate x1 to x3 across R12.'is pal of' using y2;
relate x4 to x1 across R12.'is buddy of' using y3;
relate x5 to x1 across R12.'is pal of' using y4;
relate x1 to x6 across R12.'is buddy of' using y5;
// Rox's friends
relate x3 to x2 across R12.'is pal of' using y6;
// Joe's friends
relate x4 to x5 across R12.'is buddy of' using y7;
relate x4 to x6 across R12.'is pal of' using y8;
// Scott's friends
relate x6 to x5 across R12.'is buddy of' using y9;


// dealers and deals
create object instance z1 of Z; z1.name = "Joe"; z1.worth = 1;
create object instance z2 of Z; z2.name = "Pat"; z2.worth = 2;
create object instance z3 of Z; z3.name = "Jason"; z3.worth = 3;
create object instance zz1 of ZZ; zz1.xaction = 1; zz1.value = -1;
create object instance zz2 of ZZ; zz2.xaction = 2; zz2.value = 2;
create object instance zz3 of ZZ; zz3.xaction = 3; zz3.value = -3;
create object instance zz4 of ZZ; zz4.xaction = 4; zz4.value = 4;
create object instance zz5 of ZZ; zz5.xaction = 5; zz5.value = -5;
create object instance zz6 of ZZ; zz6.xaction = 6; zz6.value = 6;
create object instance zz7 of ZZ; zz7.xaction = 7; zz7.value = -7;
relate z1 to z2 across R13.'sells to' using zz1;
relate z1 to z3 across R13.'buys from' using zz2;
relate z2 to z3 across R13.'sells to' using zz3;
relate z3 to z1 across R13.'buys from' using zz4;
relate z2 to z1 across R13.'sells to' using zz5;
relate z2 to z3 across R13.'buys from' using zz6;
relate z1 to z2 across R13.'sells to' using zz7;
  </pre><p>
  </p></div></div><p>
  </p></div></div><div class="appendix" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="LegalNotice-appendix"></a>Appendix F. Legal Notice</h2></div><div><div class="legalnotice"><a id="id2498638"></a><p>Reproduction or copying of "<span class="productname">MC-3020 Model
  Compiler</span> User's Guide" is prohibited
  except by express license agreement with Mentor Graphics Corporation.</p><p>Nucleus BridgePoint is a registered trademark of Mentor Graphics Corporation.
  Microsoft Windows is registered trademarks of Microsoft
  Corporation.  Solaris is a trademark of Sun Microsystems, Inc.</p><p>Other products or services mentioned in this document are
  identified by the trademark, service marks, or products names as
  designated by the companies who market these products.</p><p>RESTRICTED RIGHTS LEGEND:
  Use, duplication, or disclosure by the Government is subject
  to restrictions as set forth in subparagraphs (c)(1)(ii) of the
  Rights in Technical Data and Computer Software clause at
  252.227-7013 (48 CFR, Ch.2).</p><p>Manufacturer is:  Mentor Graphics Corporation</p><p>Enhancements provided by:
  </p><table class="simplelist" border="0" summary="Simple list"><tr><td>Radix Unlimited, USA.</td></tr><tr><td>TOYO Corporation, Japan.</td></tr><tr><td>Sony Corporation, Japan.</td></tr><tr><td>Project Technology Corporation, USA.</td></tr><tr><td>ROX Software, Inc., USA.</td></tr></table><p>
  </p></div></div></div></div><div class="highlights"><a id="LegalNotice-appendix-high"></a><p>MC-3020
is commercial software and its use is restricted and limited
by license.</p></div></div></div></body></html>
