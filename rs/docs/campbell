Dear Campbell,

I apologize for the stream of consciousness format, so I hope
you are able to glean valuable points from this note.

(Code file references are to the gendcode directory on the CD.)

2-PASS TRANSLATION
  Emphasize the idea of 2-pass translation.  This is the hallmark
  of this model compiler.  We gather statistics and then steer
  code generation based upon this analysis of the model
  (including actions).  Generation of a great deal of code and
  data is simply avoided.  Attributes, accessors and methods
  are eliminated.

  Further optimizations will come as we deliver updates on
  about a quarterly basis (as part of maintenance).

MODULARITY
  The model compiler is designed with the meta model as a guide.
  Isolation of architecture subsystems has been a goal.  Changing
  the architecture is designed to be easy.

METRICS
  Point out the reports directory (_system/reports).  There are
  several files in here that report various metrics from the
  generation.  Counts for objects, active objects, states,
  bridge wiring, extents sizes, initialization objects.
  Events (instance directed, self directed and assigner events)
  are recorded.

  The firstpass.rpt is especially interesting providing a great
  deal (on a big model) of static analysis information.  Much
  information reported on relationship generation, navigation
  and classification.

COLORING
  I have mentioned in the past the coolness of coloring objects
  as not being generated.  This is nice for building test
  scenarios using initialization objects.  There are a few
  optimization parameters to color here especially with system
  and object defaults for sizes of extents.  Registration
  allows building a domain chart in the form of domain
  declarations in the registry.clr file.

DYNAMIC MEMORY ALLOCATION
  The release version will use no dynamic memory allocation.
  (The beta version still does as scaffolding.)  We are
  considering a future version that uses a controlled mix
  of dynamic allocation and fixed block (colorable).

SPEED VS SPACE
  As you have seen, state machines are optimized for speed
  rather than space.

FRAMEWORKS
  Code frameworks for bridges and transformers are generated
  into the skeleton directory.  This speeds implementation (or
  stubbing out) of these interfaces.

8051 MEMORY MAP
  Note that generated code has run on several targets in test
  already.  Generated code even runs on the lowly 8051 8-bit MPU.
  The memory map found on the CD (as8051.map) illustrates that
  an application can fit in approximately 16k of code and 1.5k
  of RAM.

  This is real.  Real peripherals (an LCD, watchdog, etc) were
  interfaced.

GENERATED CODE
  Show the gen_as/appl_h/A_R_object.h to illustrate the struct
  (class) that is generated containing the attributes (for the row
  object).  Note how some attributes are "OPTIMIZED OUT".

  Show gen_as/appl_c/A_R_object.c to show accessors and
  relationship formalization methods.

  Show gen_as/appl_c/A_R_actions.c to show the actions.  Perhaps
  bring up this action in Model Builder and compare the code
  of the actions to the actions.  Note the commenting.

BPAL TRACE
  Show the trace.  If you cannot show it.  Show the comments in
  gen_as/appl_c/A_R_actions.c.  The tracing will generate these
  comments perfectly indented.  This is great for debug.

Good luck!
Cort.
