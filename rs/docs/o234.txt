Dear Paul, Mr. Suzuki and Ms. Kumano,

Thank you for your questions.  These questions are especially good
and illustrate a deep understanding of MC-3020 internals.  I am
pleased to answer them.

Please see answers in line below.  Respond with further questions
of for more detail or clarification.


> ---------- Forwarded message ----------
> Date: Tue, 27 Aug 2002 17:03:24 +0900
> From: suzuki@toyo.co.jp
> To: Project Technology Technical Support <support@projtech.com>
> Cc: takao@toyo.co.jp, hideki@toyo.co.jp
> Subject: Questions on MC-3020
>
> August 27, 2002    Ref.81262-rh
>
> Reference:
>
> Dear Paul-san,
>
> We have received a couple of questions from Ms. Kumano of Sony.
> Would you please provide us with your response via e-mail?
> Since Ms. Kumano will visit PT next week and is to be available
> on Friday, please explain to her if time allows you to do so.
>
> Question 1.
>
> In the current MC3020, it seems that polymorphic events are sent
> to super-class instances and then to sub-class instances.  The
> polymorphic events, therefore, are sent to cues the-number-of-
> layer times.

This is correct.  Note that events can be sent directly to
the leaf instances as well.

> In this method, it should take very long time until an event
> reaches the event-receiving sub-class.  It takes long, for
> example, when another event occurs at the same time and stays
> at a cue.  Considering the problem, Ms. Kumano believes that
> either of the following policy would be better:

Has the timing been measured in your application?  I am curious
about this taking a "very long" time.  The event mechanism in
MC-3020 is pretty light weight.  The requeue does not involve
repacking the event, so the overhead is pretty small.

However, there is room for optimization in this generated code.
See more below.


> 1) Make events from Super-class to Sub-class "self events", not
>    normal events, and make polymorphic events consumed first.

This is possible and has been considered.  This will provide a
marginal improvement over the current implementation.  It would
have the advantage of disallowing other events to come "between"
the poly event to supertype and the corresponding event to subtype
when the event queue has more than one event.

Using the self queue has a couple of problems.  Firstly, the
event is not a true event to self.  Thus, we would be using the
self queue for something other than event to self.  Secondly,
this would interfere with or complicate the calculations of
event queue sizes made during first_pass.

I think there is a better way.


> 2) Call sub-class events with synchronous function, not handling
>    polymorphic events as events from super-class to sub-class.

A similar idea has been considered.  Note that a synchronous call
has only marginally less overhead than a queued event.  However,
this approach has promise.


> 1-1. Why PT would adopt the current policy?

The current implementation is simple, clean and safe.  It takes
advantage of the existing event queuing and dispatching.  It works.

Polymorphic events were the topic of significant research during
the development of the current policy.  There was and is still some
debate concerning some academic scenarios.  [For example, consider
early versus late binding of the event to the target instance.]
A solid, clean and easily studied implementation was important.
Perhaps it is time to optimize.  :)


> 1-2. Would there be any problems if the either 1) or 2) above is
>      adopted?

As described above, using the self queue could cause some problems.
Using synchronous calls to replace the requeueing of the event
should be possible.

A third approach (1-3) that deserve consideration involves a small
change to the event queing/dispatching mechanism.  Currently,
an event is dequeued then dispatched.  Consider a slight modification
to this where the dequeueing does not actually disconnect the
event from the queue but simply returns a pointer to the lead
event.  Event "consumption" would occur as a return code from
the dispatch.  The return code would indicate whether to fully
disconnect the event from the queue.  In the case of polymorphic
events, the return code would leave the event on the queue
causing the same event (now with a new subtype target instance)
to be dispatched.

Options 1-2 and 1-3 should be considered.  Please allow us to
review your proposals in more detail and perhaps offer help.
Understand the options 1-2 and 1-3 remain in the "late-binding"
category.  The modification involves speeding up the resolution
of the subtype instance.


> Question 2:
> We understand that there are event flags to distinguish each event.
> DELAYED_EVENT, however, does not seem to be used anywhere.  Would
> you please advise us where it is used?  If it is not used anywhere,
> what is it prepared for?

Delayed events were being considered to replace the concept of a
timer event (TIM).  This may yet happen some day.  Delayed events
provide the same capability of timer events without the architectural
complexity of timer "instances".


> Question 3!'
> For GetFsmReleasesEvent(), we believe TRUE is always returned.
> Would FALSE be returned in some cases?  If TRUE is always returned,
> what scalability did you expect when the function was made?

This is exactly the early preparation for the polymorphic queue
management described above.

Thank you for your questions.  Please continue to allow us to help.

Thank you,
Cortland Starrett


> We appreciate your cooperation.
>
> Best regards,
> -----
> Toshiyasu Suzuki/TOYO Corporation
> 1-6, Yaesu 1-chome, Chuo-ku, Tokyo 103-8284, Japan
> suzuki@toyo.co.jp/Tel:+81-3-3279-0771/Fax:+81-3-5205-2030
