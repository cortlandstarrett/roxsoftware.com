Dear Campbell,

I will answer only a few of these tonight...

> While we're getting them organised with evaluation 
> agreements etc., here are some questions I was unable to
> answer in the meeting . . .
> 
> - What are the code and data space overheads for an
> object, an instance and an event.
> - Is the event list preallocated and if so, how does the
> architecture work out how large to make it.
> - How are self directed events prioritised ?

MC-3020 adheres to all Shlaer-Mellor event rules.  Self-directed
events are delivered ahead of general instance directed events.
Multiple self-directed events from the same state action (although
bad modeling) are delivered in the sequence generated.

(This is implemented with a separate queue for self-directed events.)

> - How is the event queue managed when dequing events ?
> (ie are events shuffled or is there a top and tail 
> pointer?)

The event queues are circularly linked lists with head and tail.

> - How is the instance database managed ? (How are 'holes'
> left by deletions reused?)

Instance collections (extents) are maintained in a pair of singly
linked lists (or future hash tables).  I refer to these lists as
the "animate" (live, in use) and the "inanimate" (space allocated
but not in use at the current time) extents.  At creation and
deletion, an instance is extracted from one list and inserted into
the alternate list.

A default extent size can be colored for the system.  Individual
colors are expected to define the extent size for each object.

> - What is the event taker implementation ?
> - How has Run Jitter been dealt with ? (Run Jitter is the
> pseudo random variation of event despatch lag time caused 
> by other actions in the system getting in before the 
> critical one). This looks like they need priorities by 
> colouring, but Dan said that they'd eliminated it entirely 
> and wanted to know our solution.

The first release of MC-3020 has no prioritization.  It will
follow shortly as it is high on the priority list.

More info later.
Cort.

> They also pointed out that an event dispatcher implemented 
> on a per object basis as it is in MC 3020 would be wasteful 
> of code space if there were very many objects. I pointed 
> out that all these kinds of things were space/speed trade-
> offs. They have severe code space restrictions (I didn't 
> mention the 16k for autosampler because it was obvious 
> they'll need tighter than this).
> 
> I could have found out some of this stuff for myself and 
> probably will, but there wasn't time before the meeting 
> nor during it. I'll be looking for some of these answers 
> myself in the MC-3020 archetypes.
> 
> hope this is useful, please pass any answers to me when you
> have them.
